<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DynamicLoadingKit</name>
    </assembly>
    <members>
        <member name="T:DynamicLoadingKit.ActiveGrid">
            <summary>
            Defines a grid containing <see cref="T:DynamicLoadingKit.ActiveGridCells" href="ActiveGridCells.html">ActiveGridCells</see>. Provides for
            the manipulation of these cells and other actions.
            <para>For the inspector options below, note that some options have <em>(DO)</em> at the end of their description. This indicates that the option is a default option 
            and will only be used when no persistent data for the Active Grid is present, such as when the Active Grid is first added to
            the scene in the Editor.</para>
            <para>Finally, an Active Grid should only be disabled (or its game object disabled) if it is being used as a prototype to create active grids 
            at runtime. Do not disable an Active Grid with the intention of enabling/using it at a later time, as this will not work properly. Instead, 
            you should create the Active Grid via the Component Manager when it is needed, and destroy it when it is no longer needed.</para>
            </summary>
            <title>ActiveGrid Class</title>
            <category>Primary Components</category>
            <navigationName>ActiveGrid</navigationName>
            <fileName>ActiveGrid.html</fileName>
            <syntax>public sealed partial class ActiveGrid : MonoBehaviour, <see href = "IIdentifiable.html">IIdentifiable</see>, <see cref="T:DynamicLoadingKit.IWorldUser" href="IWorldUser.html">IWorldUser</see></syntax>
            
            <inspector name="AllowGridToForceWorldShifts" type="bool">Should the Boundary Monitor associated with the Active Grid monitor
            the World Shift Boundary of the World the Active Grid is synced to when the game starts? This is only used when the World the Active Grid 
            is synced to is set to stay centered around the origin.
            <para>If enabled, a world shift will be initiated when the player crosses the world shift boundary. 
            If you have multiple Active Grids/Players, issues can arise when the players are at opposite ends of the World. One player might force a world shift that forces a different player  
            accross the opposite boundary, which forces a shift in the opposite direction. This in turns forces the first player across the original boundary, 
            causing and endless cycle of world shifts. For this reason, it is not recommended to have multiple Active Grids/Players able to shift the same World at the same time.</para>
            <para>This can be done by disabling this option on all but one Active Grids (probably the main player on a client).</para>
            </inspector>
            
            <inspector name = "Boundary Monitor" type = "BoundaryMonitor" link = "BoundaryMonitor.html">The Boundary Monitor that should be used to
            track the player's position (must be provided for dynamic loading and reset boundary monitoring to work).</inspector>
            
            <inspector name="Cell Users Enabled" type="bool">Should Cell Users be enabled at the start of the scene? If disabled, the cell objects
            associated with the cells will not be loaded. <em>(DO)</em></inspector>
            
            <inspector name = "Column Index" type ="int">The column index of the bottom left most cell in the Active Grid, used only when
            a player Transform is not associated with the Active Grid. <em>(DO)</em></inspector>
            
            <inspector name = "Grid ID" type ="int">The ID that uniquely identifies this Active Grid. If multiple Active Grids exist in the same scene,
            it is imperative that their ID's be unique. When creating Active Grid's at runtime via the 
            <see cref="T:DynamicLoadingKit.ComponentManager" href="ComponentManager.html">Component Manager</see>, a unique ID is automatically
            assigned to the created Active Grid.</inspector>
            
            <inspector name = "Inner Columns" type ="int">The number of columns in the inner area of the Active Grid. <em>(DO)</em></inspector>
            
            <inspector name = "Inner Layers" type ="int">The number of layers in the inner area of the Active Grid 
            (relevant only when the Active Grid is synced to a three dimensional 
            <see cref="T:DynamicLoadingKit.World" href="World.html">World</see>). <em>(DO)</em></inspector>
            
            <inspector name = "Inner Rows" type ="int">The number of rows in the inner area of the Active Grid. <em>(DO)</em></inspector>
            
            <inspector name = "Layer Index" type ="int">The layer index of the bottom left most cell in the Active Grid, used only when
            a player Transform is not associated with the Active Grid and the Active Grid is 
            synced to a three dimensional <see cref="T:DynamicLoadingKit.World" href="World.html">World</see>. <em>(DO)</em></inspector>
            
            <inspector name="Monitor Inner Area Boundaries" type="bool">Should the Boundary Monitor associated with the Active Grid monitor
            the Inner Area Boundaries of the Active Grid when the scene starts? Unchecking this option will effectively disable dynamic loading. 
            Note that this option is only displayed when a Boundary Monitor is supplied to the Active Grid. <em>(DO)</em></inspector>
            
            <inspector name = "Outer Ring Width" type ="int">The width of the outer ring of cells that surrounds the inner area of the Active Grid. <em>(DO)</em></inspector>
            
            <inspector name = "Player" type ="Transform" link="http://docs.unity3d.com/ScriptReference/Transform.html">
            The Transform of the player that is associated with the Active Grid. The position of this transform should reflect your player's position in the world.</inspector>
            
            <inspector name = "Player Mover" type ="PlayerMover" link="PlayerMover.html">The Player Mover component that should be used
            to move the player. If left blank, the player will be moved via it's Transform, which may or may not cause issues depending upon
            your movement system (are you using a Rigidbody, Character Controller, etc.?).
            <para>Please visit the Player Mover page for more information.</para></inspector>
            
            <inspector name = "Row Index" type ="int">The row index of the bottom left most cell in the Active Grid, used only when
            a player Transform is not associated with the Active Grid. <em>(DO)</em></inspector>
            
            <inspector name = "World" type ="World" link="World.html">The World the Active Grid should start synced to. <em>(DO)</em></inspector>
        </member>
        <member name="E:DynamicLoadingKit.ActiveGrid.CellPlayerIsInChanged">
            <summary>
            An event that can be subscribed to in order to receive 
            notifications when the cell the player is in changes. Please keep the following points in mind:
            <para>
            1) The cell in question is the 
            endless grid cell the player is in, which can change, among other reasons, as the 
            result of a world shift. In this case, the WorldGridCellPlayerIsIn and 
            WorldCellPlayerIsIn will remain the same as before the event was fired. In other situations, the 
            WorldCell will change but WorldGridCellPlayerIsIn will remain the same (if the player 
            is transported to an endless grid cell that is associated with the same world grid cell as the 
            previous endless grid cell the player was on).
            </para>
            <para>
            2) When the Active Grid becomes desynced from a World, the WorldCellPlayerIsIn 
            will be null and EndlessGridCellPlayerIsIn/WorldGridCellPlayerIsIn values invalid, and this 
            event will stop firing (until a new world is synced).
            </para> 
            <para>
            3) The WorldCellPlayerIsIn property will also return null if a World Cell cannot be retrieved 
            from the World 
            for a given cell. This can occur if that cell on the World is not active, either 
            because the component manager has not been initialized or had time to fully load the world 
            objects, that cell is simply empty, or this Active Grid and any other World users are not 
            "using" that cell (which can occur, for instance, if the Active Grid's Monitor 
            Inner Area Boundaries option is disabled). In any case, EndlessGridCellPlayerIsIn and 
            WorldGridCellPlayerIsIn will still be valid.
            </para>
            <para>
            4) This event will not fire upon initialization of the Active Grid, only during gameplay as the player 
            moves around the scene, or when the Active Grid syncs/desyncs from a world during gameplay. 
            If you need to find the world grid cell, endless grid cell, or World Cell that the player 
            is in (including at the start of the game), you should use the appropriate methods on the World class.
            </para>
            <para>
            5) The event args are reused for each event, so once a new event fires the 
            WorldCellPlayerIsIn, EndlessGridCellPlayerIsIn, and WorldGridCellPlayerIsIn values will no 
            longer be accurate for the previous event (though some values may be the same, depending upon 
            the situation which caused the new event to fire).
            </para>
            <para>
            6) The event utilizes 
            <see cref="T:DynamicLoadingKit.CellPlayerIsInChangedEventArgs" href="WorldCellPlayerIsInChangedEventArgs.html">CellPlayerIsInChangedEventArgs</see> 
            and subscribers must have a signature of 
            void MethodName(object sender, CellPlayerIsInChangedEventArgs paramaterName).
            </para>
            </summary>
            <validSubscriber>void MethodName(object sender, CellPlayerIsInChangedEventArgs parameterName)</validSubscriber>
        </member>
        <member name="E:DynamicLoadingKit.ActiveGrid.PlayerMovedByGrid">
            <summary>
            An event that can be subscribed to in order to receive notifications when the player is 
            moved by the Active Grid. This is most useful when trying to sync an action to the player being 
            moved during one of the Active Grids move methods.
            <para>
            Note, the event args are reused for each event, so once a new event fires the Player values 
            will no longer be accurate for the previous event. If you need to use this 
            value at a future time, you should store them locally.
            </para>
            <para>
            The event utilizes 
            <see cref="T:DynamicLoadingKit.PlayerMovedByGridEventArgs" href="PlayerMovedByGridEventArgs.html">PlayerMovedByGridEventArgs</see> 
            and subscribers must have a signature of void MethodName(object sender, PlayerMovedByGridEventArgs paramaterName).
            </para>
            </summary>
            <validSubscriber>void MethodName(object sender, PlayerMovedByGridEventArgs parameterName)</validSubscriber>
        </member>
        <member name="E:DynamicLoadingKit.ActiveGrid.WorldSyncedToChanged">
            <summary>
            An event that can be subscribed to in order to receive notifications when the Active Grid is 
            synced to a new World. When the sync occurs as a result of TryMovePlayerToLocationOnNewWorld, 
            the sync "occurs" when the player is moved, otherwise the sync occurs just before the 
            coroutine that triggered the sync exits.
            <para>
            Note, the event args are reused for each event, so once a new event fires the OldWorld 
            and NewWorld values will no longer be accurate for the previous event. If you need to use this 
            value at a future time, you should store them locally.
            </para>
            <para>
            The event utilizes 
            <see cref="T:DynamicLoadingKit.WorldSyncedToChangedEventArgs" href="WorldSyncedToChangedEventArgs.html">WorldSyncedToChangedEventArgs</see> 
            and subscribers must have a signature of void MethodName(object sender, WorldSyncedToChangedEventArgs paramaterName).
            </para>
            </summary>
            <validSubscriber>void MethodName(object sender, WorldSyncedToChangedEventArgs parameterName)</validSubscriber>
        </member>
        <member name="P:DynamicLoadingKit.ActiveGrid.ActiveGridType">
            <summary>
            Gets a value indicating the Active Grid Type of the Active Grid.
            </summary>
            <type link="ActiveGridType.html">ActiveGridType</type>
        </member>
        <member name="P:DynamicLoadingKit.ActiveGrid.AreCellUsersEnabled">
            <summary>
            Gets a value indicating whether cell users are enabled for the Active Grid. This is mostly useful 
            if you are not seeing objects loaded in your scene and you're not sure why. This value may be false 
            (and thus no objects loaded) if you have created the Active Grid at runtime and not called one of the 
            TryLoadCellObjects methods, or if you have called one of the TryUnloadCellObjects methods.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DynamicLoadingKit.ActiveGrid.AreCellUsersLoaded">
            <summary>
            Gets a value indicating whether cell users are loaded for the Active Grid. Note that the actual physical cell objects may not be in th scene when this value returns true, as it's possible the World is in the process of loading them still.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DynamicLoadingKit.ActiveGrid.ID">
            <summary>
            Gets the identification number of the Active Grid.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DynamicLoadingKit.ActiveGrid.IsActiveGridPersistent">
            <summary>
            Gets a value indicating whether the Active Grid is persistent between game sessions.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DynamicLoadingKit.ActiveGrid.IsInitialized">
            <summary>
            Gets a value indicating whether ManagedAwake has been called (and successfully run) already. 
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DynamicLoadingKit.ActiveGrid.IsBusy">
            <summary>
            Gets a value indicating whether the current Active Grid is busy. "Busy" simply means a multi frame action (aka, a coroutine method)
            is currently being executed (such as the method <see href = "#TryMovePlayerToLocation">TryMovePlayerToLocation</see>).
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DynamicLoadingKit.ActiveGrid.PersistentDataSaveKey">
            <summary>
            Gets the Persistent Data Save Key for the Active Grid. This is only valid if 
            "Use Custom Save/Load Solution" is disabled on your Component Manager.
            </summary>
            <type>string</type>
        </member>
        <member name="P:DynamicLoadingKit.ActiveGrid.Player">
            <summary>
            Gets the current Player associated with the Active Grid.
            </summary>
            <type>Transform</type>
        </member>
        <member name="P:DynamicLoadingKit.ActiveGrid.PlayerMover">
            <summary>
            Gets the current Player Mover associated with the Active Grid.
            </summary>
            <type link="PlayerMover.html">PlayerMover</type>
        </member>
        <member name="P:DynamicLoadingKit.ActiveGrid.PlayerReadyToBeMoved">
            <summary>
            During an Active Grid operation where the player needs to be moved and true was passed in for waitForCommandBeforeMovingPlayer,
            this can be used to determine whether the player is ready to be moved. This will be true if the area the player is being moved to 
            has successfully been loaded.
            <para>This is most useful when trying to sync other actions/events to 
            the player being moved (such as a portal effect or transport sound).</para>
            <para>To use it effectively, you'd call StartCoroutine(any Active Grid Method that moves the player, such as 
            <see cref="M:DynamicLoadingKit.ActiveGrid.TryMovePlayerToLocation(UnityEngine.Vector3,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Single)" href="#TryMovePlayerToLocation">TryMovePlayerToLocation</see>). When you are ready 
            for the player to be moved, you query this property to make sure the area to move the player to has been loaded. 
            Once this returns true, you play your effect/sound and call the same Active Grid's 
            <see cref="M:DynamicLoadingKit.ActiveGrid.InitiatePendingMove" href="#InitiatePendingMove">InitiatePendingMove</see> method at the appropriate time during that 
            effect/sound.</para>
            <para>The player will be moved either in the same frame or a couple of frames after, depending on whether a Player Mover 
            component is linked to the Active Grid. In the case of the latter, the player should not notice the delay.</para>
            </summary>
        </member>
        <member name="P:DynamicLoadingKit.ActiveGrid.WorldSyncedTo">
            <summary>
            Gets the current World the Active Grid is synced to.
            </summary>
            <type link = "World.html">World</type>
        </member>
        <member name="M:DynamicLoadingKit.ActiveGrid.GetColumnsInUse">
            <summary>
            Gets the total number of columns currently being used by the Active Grid.
            </summary>
            <syntax>public int GetColumnsInUse()</syntax>
            <displayName id="GetColumnsInUse">GetColumnsInUse()</displayName>
            <returns type = "int">Returns 0 when no active grid cells have been created or the Active Grid Type is set to 
            Sectioned_Grid, otherwise a value greater than 0.
            </returns>
        </member>
        <member name="M:DynamicLoadingKit.ActiveGrid.GetLayersInUse">
            <summary>
            Gets the total number of layers currently being used by the Active Grid.
            </summary>
            <syntax>public int GetLayersInUse()</syntax>
            <displayName id="GetLayersInUse">GetLayersInUse()</displayName>
            <returns type = "int">Returns 0 when no active grid cells have been created or the Active Grid Type is set to 
            Sectioned_Grid, otherwise a value greater than 0 (but which will alwyas be 1 when the grid is synced to a 2D world).
            </returns>
        </member>
        <member name="M:DynamicLoadingKit.ActiveGrid.GetRowsInUse">
            <summary>
            Gets the total number of rows currently being used by the Active Grid.
            </summary>
            <syntax>public int GetRowsInUse()</syntax>
            <displayName id="GetRowsInUse">GetRowsInUse()</displayName>
            <returns type = "int">
            Returns 0 when no active grid cells have been created or the Active Grid Type is set to 
            Sectioned_Grid, otherwise a value greater than 0.
            </returns>
        </member>
        <member name="M:DynamicLoadingKit.ActiveGrid.GetDistanceFromInnerAreaOfGrid(DynamicLoadingKit.Cell)">
            <summary>
            Gets the distance that a cell is from the inner area of the active grid. 
            This effectively tells you what ring the cell is in 
            when using an outer ring grid. 
            <para>
            You can use this info for a variety of purposes, for instance you could modify loaded terrains to use a lower resolution 
            at runtime if they are farther from the grids center.
            </para>
            </summary>
            <param name="cellOnEndlessGrid" type="Cell" link="Cell.html">
            The cell whose distance from center you want. It should be one based and a cell on your worlds endless grid.
            </param>
            <returns type="int">0 will be returned if the cell is part of the inner grid, 1 if the cell 
            is in the first ring around the inner grid, and so on. A -1 will be returned if the ring cannot be determined or 
            if using a sectioned grid.
            </returns>
            <syntax>
            public int GetDistanceFromInnerAreaOfGrid(Cell cellOnEndlessGrid)
            </syntax>
            <displayName id="GetDistanceFromInnerAreaOfGrid">
            GetDistanceFromInnerAreaOfGrid(Cell)
            </displayName>
        </member>
        <member name="M:DynamicLoadingKit.ActiveGrid.PreInitialize_SetWorld(DynamicLoadingKit.World,System.Boolean)">
            <summary>
            Sets the initial World for the Active Grid to use. This must be called before the Active Grid has been 
            initialized, and if the Active Grid is persistent, the world must also be persistent.
            <para>Note, this will not fire the ActiveGridSyncedToNewWorld event.</para>
            </summary>
            <param name="world" type="World" link="World.html">
            The world for the Active Grid to use.
            </param>
            <param name="overwriteWorldFromPersistentData" type="bool">
            If true, the passed in World will be used regardless of whether persistent data exist for the Active Grid. If false, the passed 
            in world will be used if a) no persistent data exist for the Active Grid, or b) persistent data exist, but no world was found 
            in the data (happens when active grid was synced to a non persistent world when data was saved).
            </param>
            <exception name="InvalidOperationException">
            Thrown when the Active Grid has already been initialized.
            </exception>
            <displayName id="PreInit_SetWorld">
            PreInitialize_SetWorld(World, bool)
            </displayName>
            <syntax>
            public void PreInitialize_SetWorld(World world, bool overwriteWorldFromPersistentData)
            </syntax>
        </member>
        <member name="M:DynamicLoadingKit.ActiveGrid.GetPersistentStringSaveData(System.Text.StringBuilder)">
            <summary>
            Gets the Active Grids persistent save data in the form of a string. This string can be used to
            maintain the grids state between game sessions. This is done by loading the string via the
            <see cref="M:DynamicLoadingKit.ActiveGrid.SetStateFromSaveData(System.String,DynamicLoadingKit.TryGet{System.Int32,DynamicLoadingKit.World})" href="#SetStateFromSaveData1">
            SetStateFromSaveData(string, TryGet&lt;int, World&gt;)
            </see> method. If no string builder is provided, one is created.
            <para>
            It is unlikely that you will ever need to call this method yourself, as the 
            <see cref="T:DynamicLoadingKit.ComponentManager" href = "ComponentManager.html">ComponentManager</see> handles
            persistent data saving/loading automatically.
            </para>
            </summary>
            <param name="stringBuilder" type = "StringBuilder">
            An optional stringbuilder. This allows you to provide a reusable string builder to reduce
            some garbage generation.
            </param>
            <displayName id ="GetPersistentStringSaveData">
            GetPersistentStringSaveData([StringBuilder])
            </displayName>
            <syntax>
            public string GetPersistentStringSaveData(StringBuilder stringBuilder = null)
            </syntax>
            <returns type = "string">
            The persistent save data in the form of a string.
            </returns>
        </member>
        <member name="M:DynamicLoadingKit.ActiveGrid.TryShiftGrid(DynamicLoadingKit.Direction)">
            <summary>
            Try to shift the Active Grid in the <see cref="T:DynamicLoadingKit.Direction" href = "Direction.html">Direction</see> 
            specified. Only use this if no player is assigned to the grid (if there is a player, you should 
            allow the Active Grid to automatically shift on its own).
            <para>
            The shift will also fail to execute if the grid is already busy executing a multi frame action 
            (coroutine starting with Try), in which case an exception is thrown.
            </para>
            <para>
            It's unlikely you will need to call this method manually. 
            Usually, you will have a Boundary Monitor that tracks 
            the player's position, forcing the grid to shift when the 
            player crosses specific boundaries of the Active Grid. 
            If you do plan on manually shifting the grid, disable or remove the boundary monitor and player.
            </para>
            <para>
            If the Grid Type is set to Sectioned, this will shift the 
            active section in the direction specified, which 
            may or may not change the cells that are currently loaded.
            </para>
            </summary>
            <param name="directionToShiftGrid" type = "Direction" link = "Direction.html">
            The direction to shift the grid.
            </param>
            <displayName id = "TryShiftGrid">
            TryShiftGrid(Direction)
            </displayName>
            <syntax>
            public void TryShiftGrid(Direction directionToShiftGrid)
            </syntax>
            <exception name="InvalidOperationException">
            Thrown when this method is called before the grid has been initialized or while the Active Grid is busy executing a 
            multi frame action. Check IsBusy before 
            calling methods that begin with "Try".
            </exception>
            <exception name="MissingComponentException">
            Thrown when this method is called while the Active Grid is not synced to a 
            <see cref="T:DynamicLoadingKit.World" href="World.html">World</see>.
            </exception>
        </member>
        <member name="M:DynamicLoadingKit.ActiveGrid.TryMakeCellOriginCell(DynamicLoadingKit.Cell,System.Boolean,System.Boolean,System.Nullable{UnityEngine.Vector3},System.Boolean,System.Single,System.Boolean)">
            <summary>
            Tries to make the passed in cell the origin cell of the world the Active Grid is currently synced to.
            This is useful if you want to move the player to a cell but want to keep the player and 
            world close to the origin, as this method will set the passed in cell so it's location 
            is the origin of the world. This may be necessary to avoid floating point errors.
            It's important that if movePlayerAfterChange is true, the playerPositionAfterChange 
            you pass in falls within the cell at the world's origin after this cell is made to be the origin cell.
            </summary>
            <param name="cell" type="Cell" link="Cell.html">
            The cell which will become the origin cell of the World the Active Grid is currently synced to.
            </param>
            <param name="disablePlayerDuringChange" type="bool">
            If true, the game object the player transform is on will be deactivated while the origin 
            cell is changed, and activated once the process has finished (and the player has been moved if movePlayerAfterChange is true).
            <para>
            If you don't want the player to be deactivated, pass in false, but keep in mind 
            that you will need to freeze the player's movement in some way before running this 
            method, as the terrain the player is on will likely be removed in the process.
            </para>
            </param>
            <param name="movePlayerAfterChange" type="bool">
            If true, the player will be moved after the origin cell has been changed.
            </param>
            <param name="playerPositionAfterChange" type="Vector3">
            If movePlayerAfterChange is true, the player will be moved to this location.
            </param>
            <param name="setPlayerYPositionBasedOnTerrain" type="bool">
            If movePlayerAfterChange and setPlayerYPositionBasedOnTerrain are true, the player's y location will be 
            set based on the terrain at the x and z location (i.e, the y location in playerPositionAfterChange 
            will be ignored).
            </param>
            <param name="playerYOffset" type="float">
            If movePlayerAfterChange and setPlayerYPositionBasedOnTerrain are true, 
            you can pass in an offset value which will be added to the player's calculated 
            position (based on the terrain). This is necessary since setting the player's 
            y position to the calculated position would likely cause the player to 
            overlap the terrain, which is not ideal.
            </param>
            <param name="positionRelativeToOriginCell" type="bool">
            Is the playerPositionAfterChange relative to world space (false) or the new origin cell (true). If 
            setPlayerYPositionBasedOnTerrain is false, this also dictates whether the y value of 
            playerPositionAfterChange is relative to the world or origin cell.
            <para>
            If the position is relative 
            to the origin cell, then the final position the player will be moved to is 
            playerPositionAfterChange + OriginCell.position. If the position is relative to world space, then 
            playerPositionAfterChange is the position the player will be moved to.
            </para>
            <para>
            Note, if the Origin Cell's position is x = 0, y = 0, and z = 0, then the player's position after the change will be the same regardless of this value.
            </para>
            </param>
            <syntax>
            public IEnumerator&lt;YieldInstruction&gt; TryMakeCellOriginCell(Cell cell, bool disablePlayerDuringChange, bool movePlayerAfterChange = false, Vector3? playerPositionAfterChange = null, bool setPlayerYPositionBasedOnTerrain = false, float playerYOffset = 1f, bool positionRelativeToOriginCell = false)
            </syntax>
            <displayName id = "TryMakeCellOriginCell">
            TryMakeCellOriginCell(Cell, bool, [bool], [?Vector3], [bool], [float], [bool])
            </displayName>
            <returns>
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.
            </returns>
            <exception name="InvalidOperationException">
            Thrown when a world is not associated with the grid, when the Active Grid has not been initialized yet, 
            when this method is called while the 
            Active Grid is busy executing a multi frame action (check IsBusy before calling ActiveGrid methods that begin with 
            "Try"), when setPlayerYPositionBasedOnTerrain is true but the current world does not use Unity Terrain or cell objects 
            are not enabled on the Active Grid, or when a player is not associated with the grid but movePlayerAfterChange is true.
            </exception>
        </member>
        <member name="M:DynamicLoadingKit.ActiveGrid.TryMovePlayerToLocation(UnityEngine.Vector3,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Single)">
            <summary>
            Tries to move the player associated with this Active Grid to the location specified.
            <para>
            This method fully loads the cells (and objects if necessary) around the target location before 
            moving the player (this occurs over several frames).
            </para>
            <para>
            Once loaded, if waitForCommandBeforeMovingPlayer is true, this method will yield until 
            <see cref="M:DynamicLoadingKit.ActiveGrid.InitiatePendingMove" href="#InitiatePendingMove">InitiatePendingMove</see> is called. If false, this method
            will move the player immediately after the objects at the new location are loaded.
            </para>
            <para>
            If waitForCommandBeforeMovingPlayer is true, you can query the PlayerReadyToBeMoved property to make sure the 
            Active Grid has loaded the new area before calling InitiatePendingMove (otherwise, there is no guarantee the player 
            will be moved immediately after calling InitiatePendingMove).
            </para>
            <para>
            If waitForCommandBeforeMovingPlayer is true, it's a good idea to pass in false for 
            completeMoveOnLoad.
            </para>
            <para>
            Depending on the <see cref="P:DynamicLoadingKit.ActiveGrid.PlayerMover" href = "PlayerMover.html">PlayerMover</see>
            used by this Active Grid, the actual move operation may also take several frames.
            </para>
            <para
            >This method, like all Try methods in this API, will throw an exception when
            a coroutine operation is currently being executed by this Active Grid. The best way to account for this possibility is to simply
            check to make sure the Active Grid is not busy before calling this move method, which you can do by checking
            the Active Grid's <see cref="P:DynamicLoadingKit.ActiveGrid.IsBusy" href = "#IsBusy">IsBusy</see> property.
            </para>
            </summary>
            <param name="location" type = "Vector3">
            The location to move the player to.
            </param>
            <param name="completeMoveOnLoad" type = "bool">
            If a save occurs while the move is under way, should the move be completed when that save is loaded next session? 
            If false, the move operation will effectively be cancelled when the save is loaded, in which case it is the 
            caller of this method's responsibility to resume it when the save is loaded.
            </param>
            <param name="waitForCommandBeforeMovingPlayer" type = "bool">
            If true, the new area that the player will be moved to will be loaded, but the actual move operation will
            be delayed until the <see cref="M:DynamicLoadingKit.ActiveGrid.InitiatePendingMove" href = "#InitiatePendingMove">InitiatePendingMove</see> 
            Method is called. If false, the move will be performed immediately after the new area is loaded.
            </param>
            <param name="waitForOldObjectsToBeRemoved" type="bool">
            If true, the coroutine will not exit/yield break until the pre move objects that are no longer needed are removed.
            <para>
            This is mostly useful if displaying a loading screen and you only want to remove the loading screen when the world 
            is completely up to date.
            </para>
            </param>
            <param name="setPlayerYPositionBasedOnTerrain" type="bool">
            If true, the y value in location will be ignored and the y position to move the player to will be calculated based on the 
            height of the terrain at the location to move the player to. Only set this to true if you know the Active Grid is synced 
            to a world that is using Terrains. If there is no terrain at the location, the location's y value will be used.
            </param>
            <param name="playerYOffset" type="float">
            When setPlayerYPositionBasedOnTerrain is true, this value can be used to ensure the player does not overlap the terrain. A value of 1, for instance, 
            will place the player 1 unit above the terrain's height. You will need to experiment to find the best value, as it will depend largely upon the 
            shape and height of your player's collider.
            </param>
            <syntax>
            public IEnumerator&lt;YieldInstruction&gt; TryMovePlayerToLocation(Vector3 location, bool completeMoveOnLoad, bool waitForCommandBeforeMovingPlayer, bool waitForOldObjectsToBeRemoved, bool setPlayerYPositionBasedOnTerrain = false, float playerYOffset = 1f)
            </syntax>
            <displayName id = "TryMovePlayerToLocation">
            TryMovePlayerToLocation(Vector3, bool, bool, bool, [bool], [float])
            </displayName>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.
            </returns>
            <exception name="InvalidOperationException">
            Thrown when no player or world is associated with the grid, when the Active Grid has not been initialized yet, 
            or when this method is called while the 
            Active Grid is busy executing a multi frame action (check IsBusy before calling ActiveGrid methods that begin with 
            "Try"), or when setPlayerYPositionBasedOnTerrain is true but the current world does not use Unity Terrain or cell objects 
            are not enabled on the Active Grid.
            </exception>
        </member>
        <member name="M:DynamicLoadingKit.ActiveGrid.TryMovePlayerToLocationOnNewWorld(UnityEngine.Vector3,DynamicLoadingKit.World,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Single)">
            <summary>
            Tries to move the player associated with this Active Grid to the location specified on the new World, 
            and if the move is successful, syncs the Active Grid to this new World.
            <para>
            This method fully loads the cells (and objects if necessary) around the target location before 
            moving the player (this occurs over several frames).
            </para>
            <para>
            Once loaded, if waitForCommandBeforeMovingPlayer is true, this method will yield until 
            <see cref="M:DynamicLoadingKit.ActiveGrid.InitiatePendingMove" href="#InitiatePendingMove">InitiatePendingMove</see> is called. If false, this method
            will move the player immediately after the objects at the new location are loaded.
            </para>
            <para>
            If waitForCommandBeforeMovingPlayer is true, you can query the PlayerReadyToBeMoved property to make sure the 
            Active Grid has loaded the new area before calling InitiatePendingMove (otherwise, there is no guarantee the player 
            will be moved immediately after calling InitiatePendingMove).
            </para>
            <para>
            If waitForCommandBeforeMovingPlayer is true, it's a good idea to pass in false for 
            completeMoveOnLoad.
            </para>
            <para>
            Depending on the <see cref="P:DynamicLoadingKit.ActiveGrid.PlayerMover" href = "PlayerMover.html">PlayerMover</see>
            used by this Active Grid, the actual move operation may also take several frames.
            </para>
            <para>
            This method, like all Try methods in this API, will throw an exception when
            a coroutine operation is currently being executed by this Active Grid. The best way to account for this possibility is to simply
            check to make sure the Active Grid is not busy before calling this method, which you can do by checking
            the Active Grid's <see cref="P:DynamicLoadingKit.ActiveGrid.IsBusy" href = "#IsBusy">IsBusy</see> property.
            </para>
            </summary>
            <param name="location" type = "Vector3">
            The location to move the player to.
            </param>
            <param name = "newWorldToSyncTo" type = "World" link = "World.html">
            The new World to sync to.
            </param>
            <param name="completeMoveOnLoad" type = "bool">
            If a save occurs while the move is under way, should the move be completed when that save is loaded next 
            session? If false, the move operation will effectively be cancelled when the save is loaded, in which case it is the 
            caller of this method's responsibility to resume it when the save is loaded.
            </param>
            <param name="waitForCommandBeforeMovingPlayer" type = "bool">
            If true, the new area that the player will be moved to will be loaded, but the actual move operation will
            be delayed until the <see cref="M:DynamicLoadingKit.ActiveGrid.InitiatePendingMove" href = "#InitiatePendingMove">InitiatePendingMove</see> Method 
            is called. If false, the move will be performed immediately after the new area is loaded.
            </param>
            <param name = "allowGridToForceWorldShifts" type = "bool">
            If true, the grid will be permitted to force shifts in the new World (only applies to origin centered worlds).
            </param>
            <param name="waitForOldObjectsToBeRemoved" type="bool">
            If true, the coroutine will not exit/yield break until the pre sync/move objects that are no longer needed are removed.
            <para>
            This is mostly useful if displaying a loading screen and you only want to remove the loading screen when the world 
            is completely up to date.
            </para>
            </param>
            <param name="setPlayerYPositionBasedOnTerrain" type="bool">
            If true, the y value in location will be ignored and the y position to move the player to will be calculated based on the 
            height of the terrain at the location to move the player to. Only set this to true if you know the newWorldToSyncTo uses Terrain. 
            If there is no terrain at the location, the location's y value will be used.
            </param>
            <param name="playerYOffset" type="float">
            When setPlayerYPositionBasedOnTerrain is true, this value can be used to ensure the player does not overlap the terrain. 
            A value of 1, for instance, 
            will place the player 1 unit above the terrain's height. You will need to experiment to find the best value, as it 
            will depend largely upon the shape and height of your player's collider.
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.
            </returns>
            <exception name="InvalidOperationException">
            Thrown when no player is associated with the grid, when the Active Grid has not been initialized yet, or when this 
            method is called while the Active Grid is busy 
            executing a multi frame action (check IsBusy before calling ActiveGrid methods that begin with "Try"), or 
            when setPlayerYPositionBasedOnTerrain is true but the new world to sync to does not use Unity Terrain or cell objects 
            are not enabled on the Active Grid.
            </exception>
            <syntax>
            public IEnumerator&lt;YieldInstruction&gt; TryMovePlayerToLocationOnNewWorld(Vector3 location, World newWorldToSyncTo, bool completeMoveOnLoad, bool waitForCommandBeforeMovingPlayer, bool allowGridToForceWorldShifts, bool setPlayerYPositionBasedOnTerrain = false, float playerYOffset = 1f)
            </syntax>
            <displayName id = "TryMovePlayerToLocationOnNewWorld">
            TryMovePlayerToLocationOnNewWorld(Vector3, World, bool, bool, bool, [bool], [float])
            </displayName>
        </member>
        <member name="M:DynamicLoadingKit.ActiveGrid.TrySyncToNewWorldAroundPlayer(DynamicLoadingKit.World,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Single)">
            <summary>
            Tries to sync to the new world at the player's current position.
            <para>
            This method fully loads the cells (and objects if necessary) of the new world, and then removes the 
            cells (and objects) of the old world.
            </para>
            <para>
            This method, like all Try methods in this API, will throw an exception when
            a coroutine operation is currently being executed by this Active Grid. The best way to account for this possibility is to simply
            check to make sure the Active Grid is not busy before calling this method, which you can do by checking
            the Active Grid's <see cref="P:DynamicLoadingKit.ActiveGrid.IsBusy" href = "#IsBusy">IsBusy</see> property.
            </para>
            </summary>
            <param name = "newWorldToSyncTo" type = "World" link = "World.html">
            The new World to sync to.
            </param>
            <param name="completeSyncOnLoad" type = "bool">
            If a save occurs while the sync is under way, should the sync be completed when that save is loaded next 
            session? If false, the sync operation will effectively be cancelled when the save is loaded, in which case it is the 
            caller of this method's responsibility to resume it when the save is loaded.
            </param>
            <param name = "allowGridToForceWorldShifts" type = "bool">
            If true, the grid will be permitted to force shifts in the new World (only applies to origin centered worlds).
            </param>
            <param name="waitForOldObjectsToBeRemoved" type="bool">
            If true, the coroutine will not exit/yield break until the pre sync objects that are no longer needed are removed.
            <para>
            This is mostly useful if displaying a loading screen and you only want to remove the loading screen when the world 
            is completely up to date.
            </para>
            </param>
            <param name="setPlayerYPositionBasedOnTerrain" type="bool">
            If true, once the new world is loaded, the y position of the player will be adjusted to that of the terrain the player is on (plus the playerYOffset).
            If a Player Mover exist on the Active Grid, it will be used to move the player.
            </param>
            <param name="playerYOffset" type="float">
            When setPlayerYPositionBasedOnTerrain is true, this value can be used to ensure the player does not overlap the terrain. A value of 1, for instance, 
            will place the player 1 unit above the terrain's height. You will need to experiment to find the best value, as it will depend largely upon the 
            shape and height of your player's collider.
            </param>
            <syntax>
            public IEnumerator&lt;YieldInstruction&gt; TrySyncToNewWorldAroundPlayer(World newWorldToSyncTo, bool completeSyncOnLoad, bool allowGridToForceWorldShifts, bool waitForOldObjectsToBeRemoved, bool setPlayerYPositionBasedOnTerrain = false, float playerYOffset = 1f)
            </syntax>
            <displayName id = "TrySyncToNewWorldAroundPlayer">
            TrySyncToNewWorldAroundPlayer(World, bool, bool, bool, [bool], [float])
            </displayName>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.
            </returns>
            <exception name = "RequiredComponentNotFoundException" link = "RequiredComponentNotFoundException.html">
            Thrown when a Player Transform has not been supplied to the Active Grid.
            </exception>
            <exception name="InvalidOperationException">
            Thrown when no player is associated with the grid, when the Active Grid has not been initialized yet, when this 
            method is called while the Active Grid is busy
            executing a multi frame action (check IsBusy before calling ActiveGrid methods that begin with "Try"), or 
            when setPlayerYPositionBasedOnTerrain is true but the new world to sync to does not use Unity Terrain or cell objects 
            are not enabled on the Active Grid.
            </exception>
        </member>
        <member name="M:DynamicLoadingKit.ActiveGrid.TrySyncToNewWorld(DynamicLoadingKit.World,System.Boolean,DynamicLoadingKit.Cell,System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32)">
            <summary>
            Tries to sync to the new world using the specified <see cref="T:DynamicLoadingKit.Cell" href = "Cell.html">Cell</see> 
            to construct the new Active Grid.
            <para>
            Note that the player is not moved with this method, so the Active Grid may be updated 
            immediately after this coroutine finishes running (depending on the player's position 
            in relation to the new Active Grid). For this reason, it is recommended to use one of 
            the other methods (such as 
            <see cref="M:DynamicLoadingKit.ActiveGrid.TrySyncToNewWorldAroundPlayer(DynamicLoadingKit.World,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Single)" href="#TrySyncToNewWorldAroundPlayer">
            TrySyncToNewWorldAroundPlayer
            </see>). 
            Generally, this method should only be used in the unlikely case that you are not 
            using a Player with your Active Grid.
            </para>
            <para>
            This method fully loads the cells (and objects if necessary) of the new world, 
            and then removes the cells (and objects) of the old world.
            </para>
            <para>
            This method, like all Try methods in this API, will throw an exception when
            a coroutine operation is currently being executed by this Active Grid. 
            The best way to account for this possibility is to simply
            check to make sure the Active Grid is not busy before calling this method, which you can do by checking
            the Active Grid's <see cref="P:DynamicLoadingKit.ActiveGrid.IsBusy" href = "#IsBusy">IsBusy</see> property.
            </para>
            </summary>
            <param name = "newWorldToSyncTo" type = "World" link = "World.html">
            The new World to sync to.
            </param>
            <param name="completeSyncOnLoad" type = "bool">
            If a save occurs while the sync is under way, should the sync be completed when that 
            save is loaded next session? If false, the sync operation will effectively be 
            cancelled when the save is loaded, in which case it is the 
            caller of this method's responsibility to resume it when the save is loaded.
            </param>
            <param name = "primaryCellOfGridOnNewWorld" type = "Cell" link = "Cell.html">
            The bottom left most cell of the new Active Grid when the Active Grid type is set to 
            Outer_Ring_Grid, or the cell with the active section when the type is Sectioned_Grid.
            </param>
            <param name = "allowGridToForceWorldShifts" type = "bool">
            If true, the grid will be permitted to force shifts in the new World 
            (only applies to origin centered worlds).
            </param>
            <param name="waitForOldObjectsToBeRemoved" type="bool">
            If true, the coroutine will not exit/yield break until the pre sync objects that 
            are no longer needed are removed.
            <para>
            This is mostly useful if displaying a loading screen and you only want to remove the 
            loading screen when the world 
            is completely up to date.
            </para>
            </param>
            <param name="layerOfSection" type="int">
            The layer of the active section. Can be 0 (bottom half of cell) or 1 (top half of cell). 
            This is only used when the Active Grid Type is set to Sectioned_Grid and the grid is 
            synced to a 3D world.
            </param>
            <param name="rowOfSection" type="int">
            The row of the active section. Can be 0 (lower half of cell) or 1 (upper half of cell). 
            This is only used when the Active Grid Type is set to Sectioned_Grid.
            </param>
            <param name="columnOfSection" type="int">
            The column of the active section. Can be 0 (left half of cell) or 1 (right half of cell). 
            This is only used when the Active Grid Type is set to Sectioned_Grid.
            </param>
            <syntax>
            public IEnumerator&lt;YieldInstruction&gt; TrySyncToNewWorld(World newWorldToSyncTo, bool completeSyncOnLoad, Cell firstCellOfGridOnNewWorld, bool allowGridToForceWorldShifts, bool waitForOldObjectsToBeRemoved, int layerOfSection = 0, int rowOfSection = 0, int columnOfSection = 0)
            </syntax>
            <displayName id = "TrySyncToNewWorld">
            TrySyncToNewWorld(World, bool, Cell, bool, bool, [int], [int], [int])
            </displayName>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.
            </returns>
            <exception name="InvalidOperationException">
            Thrown when this method is called before the grid has been initialized or 
            while the Active Grid is busy executing a multi frame action. 
            Check IsBusy before calling ActiveGrid methods that begin with "Try".
            </exception>
        </member>
        <member name="M:DynamicLoadingKit.ActiveGrid.TryDesyncFromCurrentWorld(System.Boolean)">
            <summary>
            Tries to de-sync the Active Grid from the World it is currently synced to.
            </summary>
            <param name="completeDesyncOnLoad" type="bool">If true, when the Active Grid's state is saved during the middle 
            of the de-sync process, it will be saved as if the de-sync process were completed (i.e., when the 
            save data is loaded, the Active Grid will not be synced to a world).</param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.
            </returns>
            <exception name="InvalidOperationException">
            Thrown when this method is called before the grid has been initialized or 
            while the Active Grid is busy executing a multi frame action. 
            Check IsBusy before calling ActiveGrid methods that begin with "Try".
            </exception>
            <displayName id="TryDesyncFromCurrentWorld">TryDesyncFromCurrentWorld(bool)</displayName>
            <syntax>public IEnumerator&lt;YieldInstruction&gt; TryDesyncFromCurrentWorld(bool completeDesyncOnLoad)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.ActiveGrid.TryLoadCellObjectsASAP">
            <summary>
            Try to have the currently synced to World load the cell objects associated with the cells of this Active Grid 
            as soon as possible.
            <para>If the Component Manager's Awake method has not passed yet, this method will result in the objects 
            being loaded in Awake/Start, otherwise the load will occur over a series of frames (as if TryLoadCellObjects 
            was called).</para>
            <para>For this reason, it's recommended to only use this method from another scripts Awake method before 
            the game starts.</para> In any other situation, you should use 
            <see cref="M:DynamicLoadingKit.ActiveGrid.TryLoadCellObjects" href="#TryLoadCellObjects">TryLoadCellObjects</see> or 
            <see cref="M:DynamicLoadingKit.ActiveGrid.TryLoadCellObjectsAndWaitForLoadToComplete" href="#TryLoadCellObjectsAndWaitForLoadToComplete">TryLoadCellObjectsAndWaitForLoadToComplete</see> instead.
            </summary>
            <syntax>
            public void TryLoadCellObjectsASAP()
            </syntax>
            <displayName id = "TryLoadCellObjectsASAP">
            TryLoadCellObjectsASAP()
            </displayName>
            <exception name="InvalidOperationException">
            Thrown when this method is called before the grid has been initialized or 
            while the Active Grid is busy executing a multi frame action. 
            Check IsBusy before calling ActiveGrid methods that begin with "Try".
            </exception>
            <exception name="MissingComponentException">
            Thrown when this method is called while the Active Grid is not synced to a 
            <see cref="T:DynamicLoadingKit.World" href="World.html">World</see>.
            </exception>
        </member>
        <member name="M:DynamicLoadingKit.ActiveGrid.TryLoadCellObjects">
            <summary>
            Try to have the currently synced to World load the cell objects associated 
            with the cells of this Active Grid.
            <para>
            The objects are loaded during the World's normal update cycle. 
            If you need the objects loaded immediately at the start of the game in Awake, use 
            <see cref="M:DynamicLoadingKit.ActiveGrid.TryLoadCellObjectsASAP" href="#TryLoadCellObjectsASAP">TryLoadCellObjectsASAP</see> instead. 
            If you need to keep track of when the objects are fully loaded, you should use 
            <see cref="M:DynamicLoadingKit.ActiveGrid.TryLoadCellObjectsAndWaitForLoadToComplete" href="#TryLoadCellObjectsAndWaitForLoadToComplete">
            TryLoadCellObjectsAndWaitForLoadToComplete</see> instead.
            </para>
            <para>
            Normally when save data is saved for an Active Grid, if a multi frame action was executing and that action requires 
            that the player's y location be set to the terrain's height, the save data will reflect that fact and the 
            Dynamic Loading Kit will attempt to set the players y location to the starting terrain's height.
            </para>
            <para>
            With this method, 
            however (and only this method), the players y position will not be set to the terrain's location, as there is no 
            way to predict when the terrain will be loaded (and the terrain must be loaded in order to get it's location and 
            set the player's y position in relation to it). If this is a problem (there's a 99% chance it won't be), you should 
            make sure that the Component Manager is handling the cell object loading rather than calling this method yourself.
            </para>
            </summary>
            <syntax>
            public void TryLoadCellObjects()
            </syntax>
            <displayName id = "TryLoadCellObjects">
            TryLoadCellObjects()
            </displayName>
            <exception name="InvalidOperationException">
            Thrown when this method is called before the grid has been initialized or 
            while the Active Grid is busy executing a multi frame action. 
            Check IsBusy before calling ActiveGrid methods that begin with "Try".
            </exception>
            <exception name="MissingComponentException">
            Thrown when this method is called while the Active Grid is not synced to a 
            <see cref="T:DynamicLoadingKit.World" href="World.html">World</see>.
            </exception>
        </member>
        <member name="M:DynamicLoadingKit.ActiveGrid.TryLoadCellObjectsAndWaitForLoadToComplete">
            <summary>
            Tries to send the Active Grid's cells to the synced to World so that the World will load 
            the Cell Objects associated with the cells. The coroutine exits only after all the 
            objects have been loaded.
            </summary>
            <syntax>
            public IEnumerator&lt;YieldInstruction&gt; TryLoadCellObjectsAndWaitForLoadToComplete()
            </syntax>
            <displayName id = "TryLoadCellObjectsAndWaitForLoadToComplete">
            TryLoadCellObjectsAndWaitForLoadToComplete()
            </displayName>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.
            </returns>
            <exception name="InvalidOperationException">
            Thrown when this method is called before the grid has been initialized or 
            while the Active Grid is busy executing a multi frame action. 
            Check IsBusy before calling ActiveGrid methods that begin with "Try".
            </exception>
            <exception name="MissingComponentException">
            Thrown when this method is called while the Active Grid is not synced to a 
            <see cref="T:DynamicLoadingKit.World" href="World.html">World</see>.
            </exception>
        </member>
        <member name="M:DynamicLoadingKit.ActiveGrid.TryUnloadCellObjects">
            <summary>
            Try to unload the cell objects associated with the cells of this Active Grid.
            <para>Will throw an exception if the grid is busy.</para>
            </summary>
            <syntax>
            public void TryUnloadCellObjects()
            </syntax>
            <displayName id = "TryUnloadCellObjects">
            TryUnloadCellObjects()
            </displayName>
            <exception name="InvalidOperationException">
            Thrown when this method is called while the Active Grid is busy executing a multi frame action. Check IsBusy before 
            calling methods that begin with "Try".
            </exception>
            <exception name="MissingComponentException">
            Thrown when this method is called while the Active Grid is not synced to a 
            <see cref="T:DynamicLoadingKit.World" href="World.html">World</see>.
            </exception>
        </member>
        <member name="M:DynamicLoadingKit.ActiveGrid.TryUnloadCellObjectsAndWaitForUnloadToComplete">
            <summary>
            Try to disable the cell users for this Active Grid and wait for the objects associated with those cell users to 
            be disabled and possibly unloaded from the scene.
            <para>
            Will throw an exception if the grid is busy.
            </para>
            </summary>
            <syntax>
            public IEnumerator&lt;YieldInstruction&gt; TryUnloadCellObjectsAndWaitForUnloadToComplete()
            </syntax>
            <displayName id = "TryUnloadCellObjectsAndWaitForUnloadToComplete">
            TryUnloadCellObjectsAndWaitForUnloadToComplete()
            </displayName>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.
            </returns>
            <exception name="InvalidOperationException">
            Thrown when this method is called while the Active Grid is busy executing a multi frame action. Check IsBusy before 
            calling methods that begin with "Try".
            </exception>
            <exception name="MissingComponentException">
            Thrown when this method is called while the Active Grid is not synced to a 
            <see cref="T:DynamicLoadingKit.World" href="World.html">World</see>.
            </exception>
        </member>
        <member name="M:DynamicLoadingKit.ActiveGrid.EnableInnerAreaBoundaryMonitoringWhenSynced">
            <summary>
            Enable Inner Area Boundary Monitoring when the grid is synced to a world. This will effectively enable dynamic loading.
            </summary>
            <syntax>public void EnableInnerAreaBoundaryMonitoringWhenSynced()</syntax>
            <displayName id = "EnableInnerAreaBoundaryMonitoringWhenSynced">EnableInnerAreaBoundaryMonitoringWhenSynced()</displayName>
            <exception name = "RequiredComponentNotFoundException" link = "RequiredComponentNotFoundException.html">
            Thrown when a Player Transform has not been supplied to the Active Grid.
            </exception>
        </member>
        <member name="M:DynamicLoadingKit.ActiveGrid.DisableInnerAreaBoundaryMonitoringWhenSynced">
            <summary>
            Disable Inner Area Boundary Monitoring when the grid is synced to a world. This will effectively disable dynamic loading.
            </summary>
            <syntax>public void DisableInnerAreaBoundaryMonitoringWhenSynced()</syntax>
            <displayName id = "DisableInnerAreaBoundaryMonitoringWhenSynced">DisableInnerAreaBoundaryMonitoringWhenSynced()</displayName>
        </member>
        <member name="M:DynamicLoadingKit.ActiveGrid.AllowGridToCauseWorldShiftsWhenSynced">
            <summary>
            Allows the grid to cause shifts in the World it is synced to (if it is synced to one). 
            This only has an effect when the grid is synced to an origin centered World
            and a player is associated with the Active Grid.
            </summary>
            <syntax>public void AllowGridToCauseWorldShiftsWhenSynced()</syntax>
            <displayName id = "AllowGridToCauseWorldShiftsWhenSynced">AllowGridToCauseWorldShiftsWhenSynced()</displayName>
            <exception name = "RequiredComponentNotFoundException" link = "RequiredComponentNotFoundException.html">
            Thrown when a Player Transform has not been supplied to the Active Grid.
            </exception>
        </member>
        <member name="M:DynamicLoadingKit.ActiveGrid.StopGridFromCausingWorldShiftsWhenSynced">
            <summary>
            Stops this Active Grid from being able to cause shifts in the World it is synced to.
            </summary>
            <syntax>public void StopGridFromCausingWorldShiftsWhenSynced()</syntax>
            <displayName id = "StopGridFromCausingWorldShiftsWhenSynced">StopGridFromCausingWorldShiftsWhenSynced()</displayName>
        </member>
        <member name="M:DynamicLoadingKit.ActiveGrid.TryChangeGridDimensions(DynamicLoadingKit.ActiveGridDimensions)">
            <summary>
            Try to change the Active Grid's dimensions. Will throw an exception if the grid is busy or if the 
            Active Grid Type is set to Sectioned_Grid.
            </summary>
            <param name = "newGridDimensions" type = "ActiveGridDimensions" link = "ActiveGridDimensions.html">
            The new Active Grid dimensions to use.
            </param>
            <syntax>
            public void TryChangeGridDimensions(ActiveGridDimensions newGridDimensions)
            </syntax>
            <displayName id = "TryChangeGridDimensions">
            TryChangeGridDimensions(ActiveGridDimensions)
            </displayName>
            <exception name="InvalidOperationException">
            Thrown when this method is called when the Active Grid Type is set to Sectioned_Grid or while the Active Grid is 
            busy executing a multi frame action. Check IsBusy before calling methods that begin with "Try".
            </exception>
        </member>
        <member name="M:DynamicLoadingKit.ActiveGrid.InitiatePendingMove">
            <summary>
            Tells a pending move operation that it is okay to proceed. This is used in conjunction with passing in true 
            for the waitForCommandBeforeMovingPlayer parameter of the 
            <see cref="M:DynamicLoadingKit.ActiveGrid.TryMovePlayerToLocation(UnityEngine.Vector3,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Single)" href = "#TryMovePlayerToLocation">TryMovePlayerToLocation</see> and  
            <see cref="M:DynamicLoadingKit.ActiveGrid.TryMovePlayerToLocationOnNewWorld(UnityEngine.Vector3,DynamicLoadingKit.World,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Single)" href = "#TryMovePlayerToLocationOnNewWorld">
            TryMovePlayerToLocationOnNewWorld
            </see> Methods.
            <para>
            This allows you to gain greater control over when the move operation is executed, which is useful in many situations.
            </para>
            </summary>
            <syntax>public void InitiatePendingMove()</syntax>
            <displayName id = "InitiatePendingMove">InitiatePendingMove()</displayName>
        </member>
        <member name="T:DynamicLoadingKit.AssetBundleLoader">
            <summary>
            A Cell Object Loader component which loads objects via Asset Bundles.
            <para>
            This loader is only available to Unity 5 users and requires that you download the Asset Bundle Manager package from the Unity 
            Asset Store, which can be found <see href="https://www.assetstore.unity3d.com/en/#!/content/45836">here</see>. It's also a good 
            idea to read the article found <see href="https://unity3d.com/learn/tutorials/topics/scripting/assetbundles-and-assetbundle-manager">here</see> 
            if you are not familiar with the Asset Bundle Manager.
            </para>
            <para>
            Also note that inspector settings found on the BaseSceneLoader class are not listed here, instead you should look at the page for 
            the BaseSceneLoader.
            </para>
            <para>
            For detailed information about Asset Bundle integration with this package, please read the
            <see href="http://deepspacelabs.net/files/Asset%20Bundle%20Loader_QuickGuide.pdf">Asset Bundle Loader Quick Guide</see>.
            </para>
            </summary>
            <title>AssetBundleLoader Class</title>
            <category>Cell Object Loaders</category>
            <navigationName>AssetBundleLoader</navigationName>
            <fileName>AssetBundleLoader.html</fileName>
            <syntax>public class AssetBundleLoader : <see cref = "T:DynamicLoadingKit.BaseSceneLoader" href = "BaseSceneLoader.html">BaseSceneLoader</see></syntax>
            <inspector name = "Log Mode" type = "AssetBundleManagerLogMode">
            Determines whether all messages are logged to the console or only errors.
            </inspector>
            <inspector name = "Streaming Type" type = "StreamingType">
            Determines the way the asset bundles will be streamed in.
            </inspector>
            <inspector name = "Server URL" type = "string">
            If Streaming Type is set to 'Remote Server', you must specify a string that identifies your server URL.
            </inspector>
            <inspector name = "Variant Possibilities" type = "string[]">
            Variants can be used to load different variations of your cell objects. You can read more about variant possibilities in the article linked 
            to at the top of this page. Set to 0 to not use variants.
            </inspector>
            <inspector name = "Active Variant" type = "string">
            When one or more variant possibilities are specified, you must set which one is the starting active variant in this field.
            </inspector>
        </member>
        <member name="P:DynamicLoadingKit.AssetBundleLoader.IsSingleFrameAttachmentPreloadRequired">
            <summary>
            Single frame loading is not possible with asset bundles, so this just returns false.
            </summary>
            <type>bool</type>
        </member>
        <member name="M:DynamicLoadingKit.AssetBundleLoader.LoadCellObjectIntoLevel(System.String)">
            <summary>
            Loads the object specified by objectName via the Asset Bundle Streaming Type specified. This name is converted to 
            lowercase first.
            </summary>
            <param name="objectName" type = "string">The name of the object/scene to load.</param>
            <displayName id = "LoadCellObjectIntoLevel">LoadCellObjectIntoLevel(string)</displayName>
            <syntax>protected sealed override YieldInstruction LoadCellObjectIntoLevel(string objectName)</syntax>
            <returns type = "YieldInstruction" link = "http://docs.unity3d.com/ScriptReference/YieldInstruction.html">An object which
            inherits from YieldInstruction. Can also be null.</returns>
        </member>
        <member name="M:DynamicLoadingKit.AssetBundleLoader.AttachCellObjectsToCellsInSingleFrame``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Single frame attachment is not possible with Asset Bundles, as they need to be downloaded, which
            takes time. Therefore, we will leave this method as not implemented, so that it throws
            an exception if called (which is possible under certain circumstances).
            <para>
            You shouldn't ever manually call this method.
            </para>
            </summary>
            <typeparam name="T">The type of cells.</typeparam>
            <param name="cells" type = "List&lt;T&gt;">The cells whose objects need to be pre loaded.</param>
            <param name="loaderID" type = "int">The ID of the user requesting the pre load.</param>
            <displayName id = "AttachCellObjectsToCellsInSingleFrame">AttachCellObjectsToCellsInSingleFrame&lt;T&gt;(List&lt;T&gt;, int)</displayName>
            <syntax>public override void AttachCellObjectsToCellsInSingleFrame&lt;T&gt;(List&lt;T&gt; cells, int loaderID)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.AssetBundleLoader.SetVariant(System.String)">
            <summary>
            Changes the active variant.
            </summary>
            <param name="variantName" type = "string">The name of the variant to set as the active variant.</param>
            <displayName id = "SetVariant1">SetVariant(string)</displayName>
            <syntax>public void SetVariant(string variantName)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.AssetBundleLoader.SetVariant(System.Int32)">
            <summary>
            Changes the active variant.
            </summary>
            <param name="index" type = "int">The index of the variant (as listed in the variant possibilities array) to set as the active variant.</param>
            <displayName id = "SetVariant2">SetVariant(int)</displayName>
            <syntax>public void SetVariant(int index)</syntax>
        </member>
        <member name="T:DynamicLoadingKit.AsyncSceneLoader">
            <summary>
            A Cell Object Loader component which loads objects via scenes. This is similar to the 
            <see cred = "SceneLoader" href="SceneLoader.html">SceneLoader</see> component, except this version uses 
            <see href="http://docs.unity3d.com/ScriptReference/Application.LoadLevelAdditiveAsync.html">Application.LoadLevelAdditiveAsync</see>.
            <para>You should never have to interact directly with this component, as the methods/properties are called/used
            as needed by the Dynamic Loading Kit.</para>
            <para>
            This method is available to all Unity 5 users and Unity 4 Pro users.
            </para>
            </summary>
            <title>AsyncSceneLoader Class</title>
            <category>Cell Object Loaders</category>
            <navigationName>AsyncSceneLoader</navigationName>
            <fileName>AsyncSceneLoader.html</fileName>
            <syntax>public sealed class AsyncSceneLoader : <see cref = "T:DynamicLoadingKit.BaseSceneLoader" href = "BaseSceneLoader.html">BaseSceneLoader</see></syntax>
            <inspector name = "Load Priority" type = "ThreadPriority" link = "http://docs.unity3d.com/ScriptReference/ThreadPriority.html">The priority of the thread used to load the scenes. 
            A lower priority means the background operation run less often and will take up less time, but will progress more slowly.</inspector>
        </member>
        <member name="M:DynamicLoadingKit.AsyncSceneLoader.LoadCellObjectIntoLevel(System.String)">
            <summary>
            Loads the scene/objects with the name objectName into the current scene via <see href="http://docs.unity3d.com/ScriptReference/Application.LoadLevelAdditiveAsync.html">Application.LoadLevelAdditiveAsync</see>.
            </summary>
            <param name="objectName" type = "string">The name of the object/scene to load.</param>
            <displayName id = "LoadCellObjectIntoLevel">LoadCellObjectIntoLevel(string)</displayName>
            <syntax>protected sealed override YieldInstruction LoadCellObjectIntoLevel(string objectName)</syntax>
            <returns type = "YieldInstruction" link = "http://docs.unity3d.com/ScriptReference/YieldInstruction.html">Returns the 
            <see href="http://docs.unity3d.com/ScriptReference/AsyncOperation.html">AsyncOperation</see> object returned by
            Application.LoadLevelAddtiveAsync.</returns>
        </member>
        <member name="T:DynamicLoadingKit.CellAction">
            <summary>
            Provides a base implementation for Cell Actions.
            <para>Cell Actions can be attached to the main objects (cell objects) used in the DLK to perform
            custom actions either before a cell is deactivated or after a cell is activated.</para>
            <para>Note that you do not need to call the methods of the Cell Actions yourself. This is done automatically by the
            DLK, although you will need to make sure the "Use Cell Actions" option is checked in the inspector of whatever
            <see cref="T:DynamicLoadingKit.PrimaryCellObjectSubController" href = "PrimaryCellObjectSubController.html">PrimaryCellObjectSubController</see> Component you are using.</para>
            </summary>
            <title>CellAction Abstract Class</title>
            <category>Secondary Components</category>
            <navigationName>CellAction</navigationName>
            <fileName>CellAction.html</fileName>
            <syntax>public abstract class CellAction : MonoBehaviour</syntax>
        </member>
        <member name="M:DynamicLoadingKit.CellAction.DoStuffBeforeCellIsDeactivated(DynamicLoadingKit.IWorldCell)">
            <summary>
            When overridden by a derived class, performs an action or actions before a cell is deactivated.
            </summary>
            <param name="worldCell" type = "IWorldCell" link = "IWorldCell.html">The world cell (who's associated cell object
            has the Cell Action attached to it) that is about to be deactivated.</param>
            <displayName id="DoStuffBeforeCellIsDeactivated">DoStuffBeforeCellIsDeactivated(IWorldCell)</displayName>
            <syntax>public virtual IEnumerator&lt;YieldInstruction&gt; DoStuffBeforeCellIsDeactivated(IWorldCell worldCell)</syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.</returns>
        </member>
        <member name="M:DynamicLoadingKit.CellAction.DoStuffAfterCellIsActivated(DynamicLoadingKit.IWorldCell)">
            <summary>
            When overridden by a derived class, performs an action or actions after a cell is activated.
            </summary>
            <param name="worldCell" type = "IWorldCell" link = "IWorldCell.html">The world cell (who's associated cell object
            has the Cell Action attached to it) that was just activated.</param>
            <displayName id="DoStuffAfterCellIsActivated">DoStuffAfterCellIsActivated(IWorldCell)</displayName>
            <syntax>public virtual IEnumerator&lt;YieldInstruction&gt; DoStuffAfterCellIsActivated(IWorldCell worldCell)</syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.</returns>
        </member>
        <member name="T:DynamicLoadingKit.CellObjectDestroyer">
            <summary>
            Provides a base implementation for Cell Object Destroyers.
            <para>Cell Object Destroyers can be used to customize the destruction strategy used by the DLK. Basically, whenever an object
            needs to be destroyed, rather than calling GameObject.Destroy on the object (the default behaviour when no Cell Object Destroyer is present),
            the object will be passed off to the Cell Object Destroyer.</para>
            <para>This allows you to create custom destruction solutions that fit your particular child-parent hiearchy.</para>
            <para>For instance,
            you can create a destroyer that destroys all grandchildren in one frame, then all those grandchildren's parents in the next frame, and finally
            the root game object in the last frame.</para>
            <para>The Destroyer must be supplied in the "Cell Object Destroyer" option in the inspector of whatever
            <see cref="T:DynamicLoadingKit.PrimaryCellObjectSubController" href = "PrimaryCellObjectSubController.html">PrimaryCellObjectSubController</see> Component you are using.</para>
            </summary>
            <title>CellObjectDestroyer Abstract Class</title>
            <category>Secondary Components</category>
            <navigationName>CellObjectDestroyer</navigationName>
            <fileName>CellObjectDestroyer.html</fileName>
            <syntax>public abstract class CellObjectDestroyer : MonoBehaviour</syntax>
        </member>
        <member name="M:DynamicLoadingKit.CellObjectDestroyer.DestroyCellObject(UnityEngine.GameObject)">
            <summary>
            When overridden by a derived class, can be used to destroy a cell object in a more performant manner than simply using GameObject.Destroy.
            </summary>
            <param name="cellObject" type = "GameObject">The cell object that needs to be destroyed.</param>
            <displayName id="DestroyCellObject">DestroyCellObject(GameObject)</displayName>
            <syntax>public abstract IEnumerator&lt;YieldInstruction&gt; DestroyCellObject(GameObject cellObject)</syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.</returns>
        </member>
        <member name="T:DynamicLoadingKit.SimpleCellObjectDestroyer">
            <summary>
            Provides a simple implementation for a Cell Object Destroyer, 
            which destroys a specific number of child objects (one level deep) per frame. 
            <para>The root object is only destroyed after all children have been destroyed.</para>
            <para>As the name implies, this is a rather simple implementation, and is not suitable for more complex child-parent hiearchies.
            In those cases, it is recommended to create a custom Cell Object Destroyer.</para>
            </summary>
            <title>SimpleCellObjectDestroyer Class</title>
            <category>Secondary Components</category>
            <navigationName>SimpleCellObjectDestroyer</navigationName>
            <fileName>SimpleCellObjectDestroyer.html</fileName>
            <syntax>public class SimpleCellObjectDestroyer : <see cref="T:DynamicLoadingKit.CellObjectDestroyer" href = "CellObjectDestroyer.html">CellObjectDestroyer</see></syntax>
            <inspector name = "Children To Destroy Per Frame" type = "int">The number of children to destroy per frame.</inspector>
        </member>
        <member name="M:DynamicLoadingKit.SimpleCellObjectDestroyer.DestroyCellObject(UnityEngine.GameObject)">
            <summary>
            Destroys x children per frame, where x is whatever you set the "Children To Destroy Per Frame" option in the insepctor to.
            </summary>
            <param name="cellObject" type = "GameObject">The cell object that needs to be destroyed.</param>
            <displayName id="DestroyCellObject">DestroyCellObject(GameObject)</displayName>
            <syntax>public sealed override IEnumerator&lt;YieldInstruction&gt; DestroyCellObject(GameObject cellObject)</syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.</returns>
        </member>
        <member name="T:DynamicLoadingKit.ActiveGridResetter">
            <summary>
            Component which was previously used to reset the Active Grid. It is no longer used, but it remains in the kit to
            avoid compatibility issues.
            </summary>
            <title>ActiveGridResetter Class</title>
            <category>Secondary Components</category>
            <navigationName>ActiveGridResetter</navigationName>
            <fileName>ActiveGridResetter.html</fileName>
            <syntax>public class ActiveGridResetter : MonoBehaviour</syntax>
        </member>
        <member name="T:DynamicLoadingKit.BaseSceneLoader">
            <summary>
            The abstract Cell Object Loader class from which the <see cref="T:DynamicLoadingKit.SceneLoader" href = "SceneLoader.html">SceneLoader</see> and
            <see cref="T:DynamicLoadingKit.AsyncSceneLoader" href = "AsyncSceneLoader.html">AsyncSceneLoader</see> components derive from.
            <para>You can derive your own custom class from this, though you will need to ensure your scene objects are properly tagged and
            set to a non-visible layer. If you wish to create your own custom CellObjectLoaderUser object, you will need to have it derive from
            SceneLoaderUser.</para>
            <para>Also note that you should never have to interact directly with this component, as the methods/properties are called/used
            as needed by the Dynamic Loading Kit.</para>
            <para>
            Setting up your scene loader components and the scenes used with them can be a bit complicated. Please take a look at 
            Chapter 4, Section 3, Setting Up Scenes for the Scene Loader Components, and Chapter 4, Section 3, Configuring
            </para>
            </summary>
            <title>BaseSceneLoader Abstract Class</title>
            <category>Cell Object Loaders</category>
            <navigationName>BaseSceneLoader</navigationName>
            <fileName>BaseSceneLoader.html</fileName>
            <syntax>public abstract class BaseSceneLoader : <see cref = "T:DynamicLoadingKit.CellObjectLoader" href = "CellObjectLoader.html">CellObjectLoader</see></syntax>
            
            <inspector name = "Unbound Object Tag" type = "string">When you created your scenes via the Generate Scenes Tool (found under Assets -> Dynamic Loading Kit), you should have
            specified a special tag to apply to the objects in your scenes. This tag is used to make searching for the newly loaded
            scene objects more efficient, so you should ensure the tag is only used with the Dynamic Loading Kit.</inspector>
            
            <inspector name = "Visible Layer" type = "int">After the objects from the scene are loaded and positioned correctly, they will be moved to this layer.
            <para>You can use any layer, as long as that layer is visible to your camera. Most likely, you will want to leave this at
            its default value of 0.</para></inspector>
        </member>
        <member name="P:DynamicLoadingKit.BaseSceneLoader.IsSingleFrameAttachmentPreloadRequired">
            <summary>
            Scene objects cannot be fully loaded/initialized in a single scene; they need one frame before they actually "exist"
            in the scene they're loaded into. Because of this, pre loading is required, and so this property is overridden
            to always return true.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DynamicLoadingKit.BaseSceneLoader.UnboundObjectTag">
            <summary>
            Gets the Unbound Object Tag set in the inspector.
            </summary>
            <type>string</type>
        </member>
        <member name="P:DynamicLoadingKit.BaseSceneLoader.VisibleLayer">
            <summary>
            Gets the Visible Layer set in the inspector.
            </summary>
            <type>int</type>
        </member>
        <member name="M:DynamicLoadingKit.BaseSceneLoader.CreateNewUser(DynamicLoadingKit.ICellObjectGroup)">
            <summary>
            Creates a new SceneLoaderUser, which is a custom type which derives from CellObjectLoaderUser. This user object
            contains a <see cref="T:DynamicLoadingKit.CellString" href = "CellString.html">CellString</see> and some other data used specifically by this class.
            </summary>
             <param name="cellObjectGroup" type="ICellObjectGroup" link="ICellObjectGroup.html">
            The cell object group being registered.
            </param>
            <displayName id = "CreateNewUser">CreateNewUser(ICellObjectGroup)</displayName>
            <syntax>protected override CellObjectLoaderUser CreateNewUser(ICellObjectGroup cellObjectGroup)</syntax>
            <returns type = "CellObjectLoaderUser">A new user object created using the worldAssociatedWithUser as input.</returns>
        </member>
        <member name="M:DynamicLoadingKit.BaseSceneLoader.LoadCellObjectIntoLevel(System.String)">
            <summary>
            When overridden in a derived class, loads the object specified by objectName via the scene loading method
            preferred by the derived class.
            </summary>
            <param name="objectName" type = "string">The name of the object/scene to load.</param>
            <displayName id = "LoadCellObjectIntoLevel">LoadCellObjectIntoLevel(string)</displayName>
            <syntax>protected abstract YieldInstruction LoadCellObjectIntoLevel(string objectName)</syntax>
            <returns type = "YieldInstruction" link = "http://docs.unity3d.com/ScriptReference/YieldInstruction.html">An object which
            inherits from YieldInstruction. Can also be null.</returns>
        </member>
        <member name="M:DynamicLoadingKit.BaseSceneLoader.PerformSingleFrameAttachmentPreload``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Pre loads the objects needed for the input cells for the user identified by loaderID. This ensures
            that when <see cref="M:DynamicLoadingKit.BaseSceneLoader.AttachCellObjectsToCellsInSingleFrame``1(System.Collections.Generic.List{``0},System.Int32)" href = "#AttachCellObjectsToCellsInSingleFrame">AttachCellObjectsToCellsInSingleFrame</see> is
            called in a subsequent frame, it will work properly.
            <para>Note that T must implement the <see cref="T:DynamicLoadingKit.IAttachableWorldCell" href = "IAttachableWorldCell.html">IAttachableWorldCell</see> interface.</para>
            </summary>
            <typeparam name="T">The type of the cells.</typeparam>
            <param name="cells" type = "List&lt;T&gt;">The cells whose objects need to be pre loaded.</param>
            <param name="loaderID" type = "int">The ID of the user requesting the pre load.</param>
            <displayName id = "PerformSingleFrameAttachmentPreload">PerformSingleFrameAttachmentPreload&lt;T&gt;(List&lt;T&gt;, int)</displayName>
            <syntax>public sealed override void PerformSingleFrameAttachmentPreload&lt;T&gt;(List&lt;T&gt; cells, int loaderID)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.BaseSceneLoader.AttachCellObjectsToCellsInSingleFrame``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Attaches the objects associated with the input cells to the cells in a single frame. Because 
            <see cref="P:DynamicLoadingKit.BaseSceneLoader.IsSingleFrameAttachmentPreloadRequired" href = "#IsSingleFrameAttachmentPreloadRequired">IsSingleFrameAttachmentPreloadRequired</see> is
            set to return true, <see cref="M:DynamicLoadingKit.BaseSceneLoader.PerformSingleFrameAttachmentPreload``1(System.Collections.Generic.List{``0},System.Int32)" href = "#PerformSingleFrameAttachmentPreload">PerformSingleFrameAttachmentPreload</see> 
            must be called in an earlier frame prior to this method being called.
            <para>Note that T must implement the <see cref="T:DynamicLoadingKit.IAttachableWorldCell" href = "IAttachableWorldCell.html">IAttachableWorldCell</see> interface.</para>
            </summary>
            <typeparam name="T">The type of the cells.</typeparam>
            <param name="cells" type = "List&lt;T&gt;">The cells whose objects need to be attached.</param>
            <param name="loaderID" type = "int">The ID of the user requesting the attachment.</param>
            <displayName id = "AttachCellObjectsToCellsInSingleFrame">AttachCellObjectsToCellsInSingleFrame&lt;T&gt;(List&lt;T&gt;, int)</displayName>
            <syntax>public sealed override void AttachCellObjectsToCellsInSingleFrame&lt;T&gt;(List&lt;T&gt; cells, int loaderID)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.BaseSceneLoader.LoadAndAttachCellObjectsToCells``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Loads and attaches the objects associated with the input cells to the cells over a period of frames.
            <para>The exact method of loading is determined by the inheriting classes implementation of
            <see cref="M:DynamicLoadingKit.BaseSceneLoader.LoadCellObjectIntoLevel(System.String)" href = "#LoadCellObjectIntoLevel">LoadCellObjectIntoLevel</see>.</para>
            </summary>
            <typeparam name="T">The type of the cells.</typeparam>
            <param name="cells" type = "List&lt;T&gt;">The cells whose objects need to be loaded and attached.</param>
            <param name="loaderID" type = "int">The ID of the user requesting the load and attachment.</param>
            <displayName id = "AttachCellObjectsToCellsInSingleFrame">LoadAndAttachCellObjectsToCells&lt;T&gt;(List&lt;T&gt;, int)</displayName>
            <syntax>public sealed override IEnumerator&lt;YieldInstruction&gt; AttachCellObjectsToCellsInSingleFrame&lt;T&gt;(List&lt;T&gt; cells, int loaderID)</syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.</returns>
        </member>
        <member name="T:DynamicLoadingKit.ComponentManager">
            <summary>
            Defines a manager which handles a variety of task, from handling persistent data to configuring all Worlds and
            Active Grids in the scene. There should only be one Component Manager in each of your scenes.
            <para>
            You can destroy and create Active Grids and Worlds during runtime via the Component Manager class. To create these 
            components at runtime, you will need to provide one or more prototypes. Prototypes store default configuration data 
            as well as references to other crucial components that cannot be identified at runtime. Prototypes should be attached 
            to disabled game objects.
            </para>
            <para>
            If Use Custom Save/Load Solution is NOT checked, the component manager will automatically search for persistent 
            data via the Persistent Data Controller provided, and will save persistent data either automatically when the game 
            exits (if Auto Save Data On Game Exit is checked), or when the Save method is called. This is excellent for 
            debugging in the editor, but for a production quality game, you will probably want to use 
            a different loading method. This can be done by checking "Use Custom Save/Load Solution," and using 
            GetSaveData and LoadSaveData.
            </para>
            <para>
            GetSaveData will return a string which reflects the current state of the component manager and all persistent 
            Active Grids and Worlds in the current scene. It can be serialized or stored in whatever manner you wish.
            </para>
            <para>
            When you wish to load your save, you deserialize the string or retrieve it from where it's stored and load it via LoadSaveData. 
            There is a limited window in which persistent data can be loaded via this method. This window 
            will close immediately when CreatePersistentActiveGrid, CreateNonPersistentActiveGrid, CreatePersistentWorld, 
            or CreateNonPersistentWorld are called for the first time. It will also close once 
            the Component Manager has been initialized. You can delay initialization by unchecking "Initialize On Awake," but you 
            will have to manually call Initialize or InitializeGradually. This technique should only be used if 
            </para>
            <para>
            A) You are instantiating or loading the Dynamic Loading Manager via Application.LoadLevel or Application.LoadLevelAsync, 
            and Awake is called on the Component Manager before you have a chance to pass in load data, or 
            </para>
            <para>
            B) You need to make sure that the initialization occurs over a series of frames for performance reasons. 
            In this case use InitializeGradually.
            </para>
            <para>
            More information on these topics (and more) can be found in the Dynamic Loading Kit Full Guide.
            </para>
            </summary>
            <title>ComponentManager Class</title>
            <category>Primary Components</category>
            <navigationName>ComponentManager</navigationName>
            <fileName>ComponentManager.html</fileName>
            <syntax>public sealed class ComponentManager : MonoBehaviour, <see href = "IIdentifiable.html">IIdentifiable</see></syntax>
            
            <inspector name="Active Grid Prototypes" type="int">
            The number of Active Grid Prototypes (see the 
            <see href="http://deepspacelabs.net/files/Dynamic%20Loading%20Kit_Full_Guide.pdf">
            Dynamic Loading Kit Full Guide
            </see> 
            for more info).
            </inspector>
            
            <inspector name="Auto Save Data On Game Exit" type="bool">
            If enabled, the Component Manager will automatically save persistent data for the Component Manager and all persistent 
            Active Grids/Worlds in the scene when the game exits.
            <para>
            This applies to exiting Play in the editor and exiting the game in a Standalone build, but only when using a 
            persistent data controller (rather than a custom save/load solution). This is a nice feature for debugging in the editor, 
            but is not really meant to be used in a standalone game.
            </para>
            </inspector>
            
            <inspector name="Component Manager ID" type="int">
            The ID that uniquely identifies this Component Manager. Because there should only be one Component Manager per scene, you shouldn't
            need to change this value.
            </inspector>
            
            <inspector name ="Initialize On Awake" type="bool">
            If enabled, the Component Manager will automatically initialize during the Awake phase. During initialization, if no persistent 
            data has been loaded (when using a custom save/load solution) or found by the Persistent Data Controller (when not using a 
            custom save/load solution), the Component Manager, Worlds, and Active Grids in the scene will be configured as if no persistent 
            data exist. (see Ch 4, Section 1, "Loading Save Data" of the Dynamic Loading Kit Full Guide for more info).
            <para>
            If disabled, you will need to call Initialize (should only be used when performance isn't an issue, such as at the start of a game)
            or InitializeGradually (better performance).
            </para>
            </inspector>
            
            <inspector name="Persistent Data Controller" type="PersistentDataController" link="PersistentDataController.html">
            The Persistent Data Controller that should be used to save the persistent data of this Component Manager and all 
            Active Grids in the scene.
            </inspector>
            
            <inspector name="Use Custom Save/Load Solution" type="bool">
            Enable this option if you wish to use a custom save/load solution (rather than a persistent data controller).
            <para>
            If checked, you should manually call GetSaveData and LoadSaveData when appropriate (see top of page for more info).
            </para>
            <para>
            You can also use this option if you don't plan on saving/loading persistent data.
            </para>
            </inspector>
            
            <inspector name="World Prototypes" type="int">
            The number of World Prototypes (see the 
            <see href="http://deepspacelabs.net/files/Dynamic%20Loading%20Kit_Full_Guide.pdf">
            Dynamic Loading Kit Full Guide
            </see> 
            for more info).
            </inspector>
        </member>
        <member name="P:DynamicLoadingKit.ComponentManager.ID">
            <summary>
            The ID that uniquely identifies this Component Manager.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DynamicLoadingKit.ComponentManager.IsInitialized">
            <summary>
            Gets a value indicating whether this Component Manager has been initialized. When using InitializeGradually, 
            will return true from the moment the method is first called. Will also return true after Initialize has been called 
            or after Awake when the "Initialize on Awake" options is checked.
            </summary>
            <type>bool</type>
        </member>
        <member name="M:DynamicLoadingKit.ComponentManager.Initialize">
            <summary>
            Initializes the Component Manager over two frames. This in turn loads any existing save data (if not already loaded), 
            and initializes all uninitialized Active Grids/Worlds in the scene.
            <para>This should only be used if "Initialize On Awake" is unchecked in the inspector, and then only at the beginning 
            of the game from another scripts Awake method. If the game has started (i.e., the update cycle is running), you should use 
            InitializeGradually instead (for performance reasons).</para>
            </summary>
            <displayName id="Initialize">Initialize()</displayName>
            <syntax>public void Initialize()</syntax>
        </member>
        <member name="M:DynamicLoadingKit.ComponentManager.InitializeGradually">
            <summary>
            Initialzes the Component Manager over a series of frames. This coroutine exits only after all initial cell objects have been 
            loaded, which allows you to display a loading screen or use some other device to hide the world until it is fully loaded.
            <para>This should only be used if "Initialize On Awake" is unchecked in the inspector.</para>
            </summary>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.
            </returns>
            <displayName id="InitializeGradually">InitializeGradually()</displayName>
            <syntax>public IEnumerator&lt;YieldInstruction&gt; InitializeGradually()</syntax>
        </member>
        <member name="M:DynamicLoadingKit.ComponentManager.LoadSaveData(System.String)">
            <summary>
            Loads save data that was retrieved via GetSaveData. This should only be called when using a custom save/load solution.
            <para>
            VERY IMPORTANT: There is a limited window in which persistent data can be loaded via this method. This window 
            will close immediately when CreatePersistentActiveGrid, CreateNonPersistentActiveGrid, CreatePersistentWorld, 
            or CreateNonPersistentWorld are called for the first time. It will also close once 
            the Component Manager has been initialized. You can delay initialization by unchecking "Initialize On Awake," but you 
            will have to manually call Initialize or InitializeGradually. This technique should only be used if 
            </para>
            <para>
            A) You are instantiating or loading the Dynamic Loading Manager via Application.LoadLevel or Application.LoadLevelAsync, 
            and Awake is called on the Component Manager before you have a chance to pass in load data, or 
            </para>
            <para>
            B) You need to make sure that the initialization occurs over a series of frames for performance reasons. 
            In this case use InitializeGradually.
            </para>
            </summary>
            <param name="saveData" type ="string">
            The save data for the Component Manager to use to setup the state of this Component Manager and all persistent Worlds 
            and Active Grids.
            </param>
            <displayName id="LoadSaveData">
            LoadSaveData(string)
            </displayName>
            <syntax>
            public void LoadSaveData(string saveData)
            </syntax>
            <exception name="InvalidOperationException">
            Thrown when this method is called and Use Custom Save/Load Solution is not checked in the inspector, or if the 
            Component Manager passed the phase where persistent save data can be loaded.
            </exception>
        </member>
        <member name="M:DynamicLoadingKit.ComponentManager.CreateNonPersistentActiveGrid(System.Int32,System.String,DynamicLoadingKit.World,System.Boolean,UnityEngine.Transform,DynamicLoadingKit.PlayerMover)">
            <summary>
            Creates and initializes a persistent Active Grid based on the prototype 
            and the specified optional parameters.
            The persistent grid data will not be saved with the component manager's save data.
            <para>
            Also keep in mind that when the Active Grid is initialized, the World the grid is 
            synced to will also be initialized, as well as this Component Manager if it has not 
            already been initialized.
            </para>
            <para>
            Note, you will need to manually load the grid's cell users in order for the 
            World the grid is synced to to load its objects. You can do this by calling 
            <see cref="M:DynamicLoadingKit.ActiveGrid.TryLoadCellObjects" href="ActiveGrid.html#TryLoadCellObjects">
            TryLoadCellObjects
            </see> 
            or 
            <see cref="M:DynamicLoadingKit.ActiveGrid.TryLoadCellObjectsAndWaitForLoadToComplete" href="ActiveGrid.html#TryLoadCellObjectsAndWaitForLoadToComplete">
            TryLoadCellObjectsAndWaitForLoadToComplete
            </see>.
            </para>
            </summary>
            <param name="prototypeToConstructGridFrom" type="int">
            The prototype to construct the grid from.
            </param>
            <param name="persistentDataToSetStateFrom" type="string">
            Optional persistent data retrieved from another Active Grid's 
            <see cref="M:DynamicLoadingKit.ActiveGrid.GetPersistentStringSaveData(System.Text.StringBuilder)" href="ActiveGrid.html#GetPersistentStringSaveData">
            GetPersistentStringSaveData
            </see> method, that can be used to set the initial state of the created Active Grid.
            <para>
            If this is not null but the 
            persistent data does not contain World information, the default World from the Active Grid Prototype will not be used. Instead, 
            the grid will act as if it has no world and sit idle, unless you pass in an alternateWorldToSyncTo. You can also sync the grid 
            to a world after creation using one of the grids sync methods (do not use 
            <see cref="M:DynamicLoadingKit.ActiveGrid.PreInitialize_SetWorld(DynamicLoadingKit.World,System.Boolean)" href="ActiveGrid.html#PreInitialize_SetWorld">PreInitialize_SetWorld</see>, 
            as the grid is automatically initialized before being returned to you).
            </para>
            </param>
            <param name="alternateWorldToSyncTo" type="World" link="World.html">
            An alternate world for the grid to start synced to. This world can be either persistent or non persistent.
            </param>
            <param name="allowAlternateWorldToOverwriteWorldFromPersistentData" type="bool">
            When persistentDataToSetStateFrom is not null and contains valid world information, and alternateWorldToSyncTo is not null, 
            allowAlternateWorldToOverwriteWorldFromPersistentData will control which world is used. 
            </param>
            <param name="alternatePlayerToAssociateWithGrid" type="Transform">
            If provided, the grid will be associated with this transform upon initialization, otherwise the grid will be associated with 
            the default Player Transform of the prototype (note, if both values are null, the grid will throw an exception if it 
            is expecting a player to be present).
            </param>
            <param name="playerMoverToAssociateWithGrid" type="PlayerMover" link="PlayerMover.html">
            If provided, the grid will use this PlayerMover when moving the Player Transform. If alternatePlayerToAssociateWithGrid is 
            set and playerMoverToAssociateWithGrid is null, the Active Grid will not use the default PlayerMover of the prototype. 
            Instead, the player mover will be set to null and the player will be moved via its Transform. If you don't want this to 
            happen, be sure to provide a player mover if you provide an alternate player.
            </param>
            <returns type="ActiveGrid" link="ActiveGrid.html">
            The created and initialized non persistent Active Grid.
            </returns>
            <exception name="InvalidPrototypeException" link ="InvalidPrototypeException.html">
            Thrown when prototypeToConstructGridFrom 
            is invalid. Valid values range from 1 to [number of prototypes].
            </exception>
            <exception name="MissingComponentException">
            Thrown when persistentDataToSetStateFrom is not null and contains a World that should exist but does not anymore.
            </exception>
            <displayName id="CreateNonPersistentActiveGrid">
            CreateNonPersistentActiveGrid(int, [string], [World], [bool], [Transform], [PlayerMover]])
            </displayName>
            <syntax>
            public ActiveGrid CreateNonPersistentActiveGrid(int prototypeToConstructGridFrom, string persistentDataToSetStateFrom = null, World alternateWorldToSyncTo = null, bool allowAlternateWorldToOverwriteWorldFromPersistentData = true, Transform alternatePlayerToAssociateWithGrid = null, PlayerMover playerMoverToAssociateWithGrid = null)
            </syntax>
        </member>
        <member name="M:DynamicLoadingKit.ComponentManager.CreatePersistentActiveGrid(System.Int32,System.String,DynamicLoadingKit.World,System.Boolean)">
            <summary>
            Creates and initializes a persistent Active Grid based on the prototype 
            and the specified optional parameters.
            The persistent grid will be saved with the component manager's save data, and 
            can only be synced with persistenet worlds.
            <para>
            Also keep in mind that when the Active Grid is initialized, the World the grid is 
            synced to will also be initialized, as well as this Component Manager if it has not 
            already been initialized.
            </para>
            <para>
            Note, you will need to manually load the grid's cell users in order for the 
            World the grid is synced to to load its objects. You can do this by calling 
            <see cref="M:DynamicLoadingKit.ActiveGrid.TryLoadCellObjects" href="ActiveGrid.html#TryLoadCellObjects">
            TryLoadCellObjects
            </see> 
            or 
            <see cref="M:DynamicLoadingKit.ActiveGrid.TryLoadCellObjectsAndWaitForLoadToComplete" href="ActiveGrid.html#TryLoadCellObjectsAndWaitForLoadToComplete">
            TryLoadCellObjectsAndWaitForLoadToComplete
            </see>.
            </para>
            </summary>
            <param name="prototypeToConstructGridFrom" type="int">
            The prototype to construct the grid from.
            </param>
            <param name="persistentDataToSetStateFrom" type="string">
            Optional persistent data retrieved from another Active Grid's 
            <see cref="M:DynamicLoadingKit.ActiveGrid.GetPersistentStringSaveData(System.Text.StringBuilder)" href="ActiveGrid.html#GetPersistentStringSaveData">
            GetPersistentStringSaveData
            </see> method, that can be used to set the initial state of the created Active Grid.
            <para>
            If this is not null but the 
            persistent data does not contain World information, the default World from the Active Grid Prototype will not be used. Instead, 
            the grid will act as if it has no world and sit idle, unless you pass in an alternateWorldToSyncTo. You can also sync the grid 
            to a world after creation using one of the grids sync methods (do not use 
            <see cref="M:DynamicLoadingKit.ActiveGrid.PreInitialize_SetWorld(DynamicLoadingKit.World,System.Boolean)" href="ActiveGrid.html#PreInit_SetWorld">PreInitialize_SetWorld</see>, 
            as the grid is automatically initialized before being returned to you).
            </para>
            </param>
            <param name="alternatePersistentWorldToSyncTo" type="World" link="World.html">
            An alternate world for the grid to start synced to. This must be a persistent world.
            </param>
            <param name="allowAlternateWorldToOverwriteWorldFromPersistentData" type="bool">
            When persistentDataToSetStateFrom is not null and contains valid world information, and alternateWorldToSyncTo is not null, 
            allowAlternateWorldToOverwriteWorldFromPersistentData will control which world is used. 
            </param>
            <returns type="ActiveGrid" link="ActiveGrid.html">
            The created and initialized non persistent Active Grid.
            </returns>
            <exception name="InvalidPrototypeException" link ="InvalidPrototypeException.html">
            Thrown when prototypeToConstructGridFrom 
            is invalid. Valid values range from 1 to [number of prototypes].
            </exception>
            <exception name="MissingComponentException">
            Thrown when persistentDataToSetStateFrom is not null and contains a World that should exist but does not anymore.
            </exception>
            <exception name="InvalidPersistenceException" link="InvalidPersistenceException.html">
            Thrown when alternatePersistentWorldToSyncTo not null and is not a persistent World.
            </exception>
            <displayName id="CreatePersistentActiveGrid">
            CreatePersistentActiveGrid(int, [string], [World], [bool])
            </displayName>
            <syntax>
            ActiveGrid CreatePersistentActiveGrid(int prototypeToConstructGridFrom, string persistentDataToSetStateFrom = null, World alternatePersistentWorldToSyncTo = null, bool allowAlternateWorldToOverwriteWorldFromPersistentData = true)
            </syntax>
        </member>
        <member name="M:DynamicLoadingKit.ComponentManager.TryGetActiveGridByID(System.Int32,DynamicLoadingKit.ActiveGrid@)">
            <summary>
            Tries to get the <see href = "ActiveGrid.html">Active Grid</see> specified by ID. 
            </summary>
            <param name="ID" type="int">The ID of the Active Grid to get.</param>
            <param name="activeGrid" type="out ActiveGrid" link="ActiveGrid.html">When this method returns, contains the
            value associated with the specified ID if the ID is found; otherwise, null.</param>
            <returns type = "bool">A bool indicating whether the ActiveGrid was found.</returns>
            <displayName id="TryGetActiveGridByID">TryGetActiveGridByID(int, out ActiveGrid)</displayName>
            <syntax>public bool TryGetActiveGridByID(int ID, out ActiveGrid activeGrid)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.ComponentManager.DestroyActiveGrid(System.Int32)">
            <summary>
            Destroys the Active Grid with IDOfActiveGridToDestroy. All cell users associated with the Active Grid are removed from cells on the World the Active Grid
            is currently synced to. If those cells have no more cell users after this removal, the cell objects are removed from the scene.
            <para>This removal is performed over a series of frames for performance reasons, however this method destroys the Active Grid immediately and does not wait
            for the cell users (and associated cell objects) to be removed from the world. If you need to wait for this process to complete (perhaps you only want to perform
            some action after the cell users/objects have been removed), use <see href = "#DestroyActiveGridAfterRemovingCellUsers">DestroyActiveGridAfterRemovingCellUsers</see> instead.</para>
            </summary>
            <param name="IDOfActiveGridToDestroy" type = "int">The ID of the Active Grid to destroy</param>
            <example>
            <code>
            class DestroyActiveGridExample
            {
                ActiveGrid myActiveGrid;
                
                public void OnDestroyActiveGrid()
                {
                    //You should only have one component manager in the scene
                    ComponentManager componentManager = GameObject.FindObjectOfType&lt;ComponentManager&gt;();
                    
                    componentManager.DestroyActiveGrid(myActiveGrid.ID);
                }
            }
            </code>
            </example>
            <exception name="InvalidIDException" link="InvalidIDException.html">
            Thrown when IDOfActiveGridToDestroy is not the ID of a valid Active Grid in the scene.
            </exception>
            <displayName id="DestroyActiveGrid">DestroyActiveGrid(int)</displayName>
            <syntax>public void DestroyActiveGrid(int IDOfActiveGridToDestroy)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.ComponentManager.DestroyActiveGridAfterRemovingCellUsers(System.Int32)">
            <summary>
            Destroys the <see cref="T:DynamicLoadingKit.ActiveGrid" href="ActiveGrid.html">Active Grid</see> with IDOfActiveGridToDestroy. All cell users associated with the Active Grid are removed from the cells on the World the Active Grid
            is currently synced to. If those cells have no more cell users after this removal, the cell objects are removed from the scene.
            <para>This removal is performed over a series of frames for performance reasons, and the Active Grid will only be destroyed after this removal
            process completes. This method should be used if you need to know when the cell users/objects are removed and want to wait for the process to complete.
            Use like any other coroutine.</para>
            </summary>
            <param name="IDOfActiveGridToDestroy" type = "int">The ID of the Active Grid to destroy</param>
            <example>Normal StartCoroutine Example
            <code>
            class DestroyActiveGridExample
            {
                ActiveGrid myActiveGrid;
                
                //This method should have been called via StartCoroutine
                public IEnumerator OnDestroyActiveGrid()
                {
                    //You should only have one component manager in the scene
                    ComponentManager componentManager = GameObject.FindObjectOfType&lt;ComponentManager&gt;();
                    
                    yield return StartCoroutine(componentManager.DestroyActiveGridAfterRemovingCellUsers(myActiveGrid.ID));
                }
            }
            </code>
            </example>
            <example>Coroutine without using StartCoroutine
            <code>
            class DestroyActiveGridExample
            {
                ActiveGrid myActiveGrid;
                
                //This method should be started using StartCoroutine or iterated over manually in another coroutine
                public IEnumerator&lt;YieldInstruction&gt; OnDestroyActiveGrid()
                {
                    //You should only have one component manager in the scene
                    ComponentManager componentManager = GameObject.FindObjectOfType&lt;ComponentManager&gt;();
                    
                    IEnumerator&lt;YieldInstruction&gt; e = componentManager.DestroyActiveGridAfterRemovingCellUsers(myActiveGrid.ID);
                    while(e.MoveNext())
                        yield return e.Current;
                }
            }
            </code>
            </example>
            <exception name="InvalidIDException" link="InvalidIDException.html">
            Thrown when IDOfActiveGridToDestroy is not the ID of a valid Active Grid in the scene.
            </exception>
            <displayName id="DestroyActiveGridAfterRemovingCellUsers">DestroyActiveGridAfterRemovingCellUsers(int)</displayName>
            <syntax>public IEnumerator&lt;YieldInstruction&gt; DestroyActiveGridAfterRemovingCellUsers(int IDOfActiveGridToDestroy)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.ComponentManager.CreatePersistentWorld(System.Int32,System.String,System.String,System.Boolean,System.Nullable{UnityEngine.Vector3},System.Boolean,System.Nullable{DynamicLoadingKit.Cell},System.Boolean)">
            <summary>
            Creates and initializes a persistent World using the information from the 
            prototype and optional parameters.
            The persistent world will be saved with the component manager's save data, 
            and both persistent and non persistent Active Grids can sync to it. Calling this method will 
            initialize this Component Manager if it has not already been initialized.
            </summary>
            <param name="prototypeToConstructWorldFrom" type="int">
            The index of the prototype to use to construct the World.
            <para>
            For instance, if the prototype is in the "Prototype 1" field, pass 1 in as the argument.
            </para>
            </param>
            <param name="persistentDataToSetStateFrom" type="string">
            Optional persistent data retrieved from another Worlds 
            <see cref="M:DynamicLoadingKit.World.GetPersistentStringSaveData(System.Text.StringBuilder)" href="World.html#GetPersistentStringSaveData1">
            GetPersistentStringSaveData
            </see> method, that can be used to set the initial state of the created World.
            </param>
            <param name="alternateGroupNameToUse" type="string">
            An alternate group name for the world to start with. The group name controls which objects are loaded by the world. If null,
            the group name from the save data will be used. If the save data is null, the default group name from the World Grid on the 
            prototype will be used.
            </param>
            <param name="allowAlternateGroupNameToOverwriteGroupNameFromPersistentData" type="bool">
            When persistentDataToSetStateFrom and alternateGroupNameToUse are both not null, 
            allowAlternateGroupNameToOverwriteGroupNameFromPersistentData will control which group name is used. 
            <para>
            A value of true will force alternateGroupNameToUse to be used, while a value of false will force the group name 
            from persistentDataToSetStateFrom to be used.
            </para>
            </param>
            <param name="alternateWorldOrigin" type="Vector3">
            An alternate world origin for the created World to use. If null, the world origin from the save data will be used. If the 
            save data is null, the prototypes world origin will be used.
            </param>
            <param name="allowAlternateWorldOriginToOverwriteWorldOriginFromPersistetnData" type="bool">
            When persistentDataToSetStateFrom and alternateWorldOrigin are both not null, 
            allowAlternateWorldOriginToOverwriteWorldOriginFromPersistetnData will control which world origin is used.
            <para>
            A value of true will force alternateWorldOrigin to be used, while a value of false will force the world origin 
            from persistentDataToSetStateFrom to be used.
            </para>
            </param>
            <param name="alternateOriginCell" type="Cell" link="Cell.html">
            An alternate origin cell for the created World to use. If null, the origin cell specified in the save data will be used.
            If the save data is null, the origin cell from the prototype is used.
            <para>
            Note, this origin cell is 1 based, i.e., the bottom left most cell of the world has an index of row = 1, column = 1, and 
            layer = 1 (for 3D worlds). The origin cell in the save data, on the other hand, is 0 based.
            </para>
            </param>
            <param name="allowAlternateOriginCellToOverwriteOriginCellFromPersistentData" type="bool">
            When persistentDataToSetStateFrom and alternateOriginCell are both not null, 
            allowAlternateOriginCellToOverwriteOriginCellFromPersistentData will control while origin cell is used.
            <para>
            A value of true will force alternateOriginCell to be used, while a value of false will force the origin cell 
            from persistentDataToSetStateFrom to be used.
            </para>
            </param>
            <returns type="World" link="World.html">
            The created and initialized persistent World.
            </returns>
            <exception name="InvalidPrototypeException" link ="InvalidPrototypeException.html">
            Thrown when prototypeToConstructWorldFrom 
            is invalid. Valid values range from 1 to [number of prototypes].
            </exception>
            <displayName id="CreatePersistentWorld">CreatePersistentWorld(int, [string], [string], [bool], [Vector3])</displayName>
            <syntax>public World CreatePersistentWorld(int prototypeToConstructWorldFrom, string persistentDataToSetStateFrom = null, string alternateGroupNameToUse = null, bool allowAlternateGroupNameToOverwriteGroupNameFromPersistentData = true, Vector3? alternateWorldOrigin = null)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.ComponentManager.CreateNonPersistentWorld(System.Int32,System.String,System.String,System.Boolean,System.Nullable{UnityEngine.Vector3},System.Boolean,System.Nullable{DynamicLoadingKit.Cell},System.Boolean)">
            <summary>
            Creates and initializes a non persistent World using the information from 
            the prototype and optional parameters.
            The non persistent world will be saved with the component manager's save data, 
            but only non persistent Active Grid's  will be able to sync to it. Calling this method will 
            initialize this Component Manager if it has not already been initialized.
            </summary>
            <param name="prototypeToConstructWorldFrom" type="int">
            The index of the prototype to use to construct the World.
            <para>
            For instance, if the prototype is in the "Prototype 1" field, pass 1 in as the argument.
            </para>
            </param>
            <param name="persistentDataToSetStateFrom" type="string">
            Optional persistent data retrieved from another Worlds 
            <see cref="M:DynamicLoadingKit.World.GetPersistentStringSaveData(System.Text.StringBuilder)" href="World.html#GetPersistentStringSaveData">
            GetPersistentStringSaveData
            </see> method, that can be used to set the initial state of the created World.
            </param>
            <param name="alternateGroupNameToUse" type="string">
            An alternate group name for the world to start with. The group name controls which objects are loaded by the world. If null,
            the group name from the save data will be used. If the save data is null, the default group name from the World Grid on the 
            prototype will be used.
            </param>
            <param name="allowAlternateGroupNameToOverwriteGroupNameFromPersistentData" type="bool">
            When persistentDataToSetStateFrom and alternateGroupNameToUse are both not null, 
            allowAlternateGroupNameToOverwriteGroupNameFromPersistentData will control which group name is used. 
            <para>
            A value of true will force alternateGroupNameToUse to be used, while a value of false will force the group name 
            from persistentDataToSetStateFrom to be used.
            </para>
            </param>
            <param name="alternateWorldOrigin" type="Vector3">
            An alternate world origin for the created World to use. If null, the world origin from the save data will be used. If the 
            save data is null, the prototypes world origin will be used.
            </param>
            <param name="allowAlternateWorldOriginToOverwriteWorldOriginFromPersistetnData" type="bool">
            When persistentDataToSetStateFrom and alternateWorldOrigin are both not null, 
            allowAlternateWorldOriginToOverwriteWorldOriginFromPersistetnData will control which world origin is used.
            <para>
            A value of true will force alternateWorldOrigin to be used, while a value of false will force the world origin 
            from persistentDataToSetStateFrom to be used.
            </para>
            </param>
            <param name="alternateOriginCell" type="Cell" link="Cell.html">
            An alternate origin cell for the created World to use. If null, the origin cell specified in the save data will be used.
            If the save data is null, the origin cell from the prototype is used.
            <para>
            Note, this origin cell is 1 based, i.e., the bottom left most cell of the world has an index of row = 1, column = 1, and 
            layer = 1 (for 3D worlds). The origin cell in the save data, on the other hand, is 0 based.
            </para>
            </param>
            <param name="allowAlternateOriginCellToOverwriteOriginCellFromPersistentData" type="bool">
            When persistentDataToSetStateFrom and alternateOriginCell are both not null, 
            allowAlternateOriginCellToOverwriteOriginCellFromPersistentData will control while origin cell is used.
            <para>
            A value of true will force alternateOriginCell to be used, while a value of false will force the origin cell 
            from persistentDataToSetStateFrom to be used.
            </para>
            </param>
            <returns type="World" link="World.html">
            The created and initialized non persistent World.
            </returns>
            <exception name="InvalidPrototypeException" link ="InvalidPrototypeException.html">
            Thrown when prototypeToConstructWorldFrom 
            is invalid. Valid values range from 1 to [number of prototypes].
            </exception>
            <displayName id="CreateNonPersistentWorld">
            CreateNonPersistentWorld(int, [string], [string], [bool], [Vector3])
            </displayName>
            <syntax>public World CreateNonPersistentWorld(int prototypeToConstructWorldFrom, string persistentDataToSetStateFrom = null, string alternateGroupNameToUse = null, bool allowAlternateGroupNameToOverwriteGroupNameFromPersistentData = true, Vector3? alternateWorldOrigin = null)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.ComponentManager.TryGetWorldByID(System.Int32,DynamicLoadingKit.World@)">
            <summary>
            Tries to get the <see cref = "T:DynamicLoadingKit.World" href = "World.html">World</see> specified by worldID. 
            </summary>
            <param name="worldID" type ="int">The ID of the World to get.</param>
            <param name="world" type = "out World" link = "World.html">When this method returns, contains the
            value associated with the specified worldID if the worldID is found; otherwise, null.</param>
            <returns type = "bool">A bool indicating whether the World was found.</returns>
            <displayName id="TryGetWorldByID">TryGetWorldByID(int, World)</displayName>
            <syntax>public bool TryGetWorldByID(int worldID, out World world)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.ComponentManager.DestroyWorld(System.Int32)">
            <summary>
            Destroys the World with IDofWorldToDestroy. All cell objects associated with the World are removed from the scene.
            This removal is performed over a series of frames for performance reasons, though the world's destruction will be reflected 
            in the persistent data if you save during the process. 
            If you care about when the removal process completes (and thus when the
            World is actually destroyed) use DestroyWorldAndWaitForCellObjectsToBeRemoved instead 
            (use it like you'd use any other coroutine).
            </summary>
            <param name="IDOfWorldToDestroy" type="int">The ID of the World to destroy</param>
            <example>
            <code>
            class DestroyWorldExample
            {
                World myWorld;
                
                public void OnDestroyWorld()
                {
                    //You should only have one component manager in the scene
                    ComponentManager componentManager = GameObject.FindObjectOfType&lt;ComponentManager&gt;();
                    
                    componentManager.DestroyWorld(myWorld.ID);
                }
            }
            </code>
            </example>
            <exception name="InvalidIDException" link="InvalidIDException.html">
            Thrown when IDOfWorldToDestroy is not the ID of a valid World in the scene.
            </exception>
            <displayName id="DestroyWorld">DestroyWorld(int)</displayName>
            <sytax>public void DestroyWorld(int IDOfWorldToDestroy)</sytax>
        </member>
        <member name="M:DynamicLoadingKit.ComponentManager.DestroyWorldAndWaitForCellObjectsToBeRemoved(System.Int32)">
            <summary>
            Same as <see cref="M:DynamicLoadingKit.ComponentManager.DestroyWorld(System.Int32)" href="#DestroyWorld">DestroyWorld</see>, except with this method you can wait for the World to complete its cell object removal and be destroyed.
            Use like you'd use any other coroutine.
            </summary>
            <param name="IDOfWorldToDestroy" type="int">The ID of the World to destroy</param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.</returns>
            <example>Normal StartCoroutine Example
            <code>
            class DestroyWorldExample
            {
                World myWorld;
                
                //This method should have been called via StartCoroutine
                public IEnumerator OnDestroyWorld()
                {
                    //You should only have one component manager in the scene
                    ComponentManager componentManager = GameObject.FindObjectOfType&lt;ComponentManager&gt;();
                    
                    yield return StartCoroutine(componentManager.DestroyWorldAndWaitForCellObjectsToBeRemoved(myWorld.ID));
                }
            }
            </code>
            </example>
            <example>Coroutine without using StartCoroutine
            <code>
            class DestroyWorldExample
            {
                World myWorld;
                
                //This method should be started using StartCoroutine or iterated over manually in another coroutine
                public IEnumerator&lt;YieldInstruction&gt; OnDestroyWorld()
                {
                    //You should only have one component manager in the scene
                    ComponentManager componentManager = GameObject.FindObjectOfType&lt;ComponentManager&gt;();
                    
                    IEnumerator&lt;YieldInstruction&gt; e = componentManager.DestroyWorldAndWaitForCellObjectsToBeRemoved(myWorld.ID);
                    while(e.MoveNext())
                        yield return e.Current;
                }
            }
            </code>
            </example>
            <exception name="InvalidIDException" link="InvalidIDException.html">
            Thrown when IDOfWorldToDestroy is not the ID of a valid World in the scene.
            </exception>
            <displayName id="DestroyWorldAndWaitForCellObjectsToBeRemoved">DestroyWorldAndWaitForCellObjectsToBeRemoved(int)</displayName>
            <syntax>public IEnumerator&lt;YieldInstruction&gt; DestroyWorldAndWaitForCellObjectsToBeRemoved(int IDOfWorldToDestroy)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.ComponentManager.Save">
            <summary>
            Saves this component manager data, including the data of all persistent Active Grids and Worlds in the scene in a single frame.
            <para>
            If you check "Use Custom Save/Load Solution," use GetSaveData and LoadSaveData instead.
            </para>
            </summary>
            <displayName id="Save">Save()</displayName>
            <syntax>public void Save()</syntax>
            <exception name="InvalidOperationException">Thrown when this method is called and Use Custom Save/Load Solution is 
            checked in the inspector, or 
            when the Component Manager was not initialized correctly due to errors</exception>
        </member>
        <member name="M:DynamicLoadingKit.ComponentManager.GetSaveData">
            <summary>
            Gets data that can be used to save/load the state of the Component Manager and all persistent Worlds and 
            Active Grids in the current scene.
            <para>
            This method should only be used when "Use Custom Save/Load Solution" is checked in the inspector.
            </para>
            </summary>
            <displayName id="GetSaveData">GetSaveData()</displayName>
            <syntax>public string GetSaveData()</syntax>
            <returns type="string">
            A string storing the data needed to save/load the Dynamic Loading Kits state.
            </returns>
            <exception name="InvalidOperationException">
            Thrown when this method is called and Use Custom Save/Load Solution is not checked in the inspector, or 
            when the Component Manager was not initialized correctly due to errors.
            </exception>
        </member>
        <member name="T:DynamicLoadingKit.DistanceBasedPrimaryCellObjectSubController">
            <summary>
            Provides an implementation for a Primary Cell Object Sub Controller that deactivates cell objects when they are not in 
            use until the cells those objects belong to are a specified distance from the active cell the player is in (when they 
            are destroyed).
            </summary>
            <title>DistanceBasedPrimaryCellObjectSubController Class</title>
            <category>Sub Controllers</category>
            <navigationName>DistanceBasedPrimaryCellObjectSubController</navigationName>
            <fileName>DistanceBasedPrimaryCellObjectSubController.html</fileName>
            <syntax>
            public sealed class DistanceBasedPrimaryCellObjectSubController : 
            <see cref="T:DynamicLoadingKit.PrimaryCellObjectSubController" href="PrimaryCellObjectSubController.html">PrimaryCellObjectSubController</see>
            </syntax>
            <inspector name="Active Grids" type="ActiveGrid[]">
            The active grids to use to determine the distance checks. Have to provide them in order to subscribe to their 
            CellPlayerIsInChanged event.
            </inspector>
            <inspector name="Distance To Destroy Objects" type="int">
            When the cell a deactivated object belongs to is this distance away from the cell the player is in, it will be destroyed.
            </inspector>
            <inspector name="Check Frequency" type="float">
            When an object is determined to be obsolete, it is added to a list. This component periodically checks to see if 
            there are any obsolete objects. This value determines the frequency of the check.
            </inspector>
        </member>
        <member name="M:DynamicLoadingKit.DistanceBasedPrimaryCellObjectSubController.CreateNewUser(DynamicLoadingKit.ICellObjectGroup,System.Int32)">
            <summary>
            Creates a new DistanceBasedPrimaryCellObjectSubControllerUser, which is a custom type which derives 
            from PrimaryCellObjectSubControllerUser. This user object contains an object pool 
            used specifically by this class.
            </summary>
            <param name="cellObjectGroup" type="ICellObjectGroup" link="ICellObjectGroup.html">
            The cell object group being registered.
            </param>
            <param name="loaderID" type="int">
            The loaderID assigned to the sub controller when it registered with the Cell Object Loader it is using.
            </param>
            <displayName id = "CreateNewUser">CreateNewUser(ICellObjectGroup, int)</displayName>
            <syntax>protected sealed override PrimaryCellObjectSubControllerUser CreateNewUser(ICellObjectGroup cellObjectGroup, int loaderID)</syntax>
            <returns type = "PrimaryCellObjectSubControllerUser">A new user object created using the worldAssociatedWithUser as input.</returns>
        </member>
        <member name="M:DynamicLoadingKit.DistanceBasedPrimaryCellObjectSubController.AttachCellObjectsToCellsInSingleFrame``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Attaches the objects associated with the input cells to the cells in a single frame. 
            Looks for the objects in the pool first, and if not found, loads the 
            objects into the scene via the Cell Object Loader.
            <para
            >Note that T must implement the 
            <see cref="T:DynamicLoadingKit.IAttachableWorldCell" href = "IAttachableWorldCell.html">IAttachableWorldCell</see> interface.
            </para>
            </summary>
            <typeparam name="T">
            The type of the cells.
            </typeparam>
            <param name="cells" type = "List&lt;T&gt;">
            The cells whose objects need to be attached.
            </param>
            <param name="primaryCellObjectSubControllerID" type="int">
            The ID of the user requesting the attachment.
            </param>
            <displayName id="AttachCellObjectsToCellsInSingleFrame">
            AttachCellObjectsToCellsInSingleFrame&lt;T&gt;(List&lt;T&gt;, int)
            </displayName>
            <syntax>
            public sealed override void AttachCellObjectsToCellsInSingleFrame&lt;T&gt;(List&lt;T&gt; cells, int primaryCellObjectSubControllerID)
            </syntax>
        </member>
        <member name="M:DynamicLoadingKit.DistanceBasedPrimaryCellObjectSubController.AttachCellObjectsToCells``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Attaches the objects associated with the input cells to the cells over a period of frames. Looks for the objects 
            in the pool first, and if not found, has the Cell Object Loader load them into the scene.
            </summary>
            <typeparam name="T">The type of the cells.</typeparam>
            <param name="cells" type = "List&lt;T&gt;">The cells whose objects need to be attached.</param>
            <param name="primaryCellObjectSubControllerID" type = "int">The ID of the user requesting the attachment.</param>
            <displayName id = "AttachCellObjectsToCells">AttachCellObjectsToCells&lt;T&gt;(List&lt;T&gt;, int)</displayName>
            <syntax>public sealed override IEnumerator&lt;YieldInstruction&gt; AttachCellObjectsToCells&lt;T&gt;(List&lt;T&gt; cells, int primaryCellObjectSubControllerID)</syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.</returns>
        </member>
        <member name="M:DynamicLoadingKit.DistanceBasedPrimaryCellObjectSubController.DetachAndProcessCellObjectsFromDeactivatedCells``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Detaches and pools the objects associated with the input cells over a period of frames. If there is not enough room 
            in the pool for an object, it is destroyed instead.
            </summary>
            <typeparam name="T">The type of the cells.</typeparam>
            <param name="deactivatedCells" type = "List&lt;T&gt;">The cells whose objects need to be detached and processed.</param>
            <param name="primaryCellObjectSubControllerID" type = "int">The ID of the user requesting the detachment and processing.</param>
            <displayName id = "DetachAndProcessCellObjectsFromDeactivatedCells">DetachAndProcessCellObjectsFromDeactivatedCells&lt;T&gt;(List&lt;T&gt;, int)</displayName>
            <syntax>public sealed override IEnumerator&lt;YieldInstruction&gt; DetachAndProcessCellObjectsFromDeactivatedCells&lt;T&gt;(List&lt;T&gt; cells, int primaryCellObjectSubControllerID)</syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.</returns>
        </member>
        <member name="T:DynamicLoadingKit.NamingConvention">
            <summary>
            A Naming Convention implemented as a scriptable object. You can create a NamingConvention asset via 
            Assets -> Dynamic Loading Kit -> Create Naming Convention Asset. This can be used to change the naming convention used 
            by the Dynamic Loading Kit for various purposes. If a NamingConvention field is visible on a component or tool and no 
            asset is provided, the default naming convention will be used (%g_%y_%x or GroupName_Row_Column). 
            <para>
            You can find more information about 
            Naming Conventions in the Quick Guides folder within your project.
            </para>
            </summary>
            <title>NamingConvention Class</title>
            <category>Other Classes</category>
            <navigationName>NamingConvention</navigationName>
            <fileName>NamingConvention.html</fileName>
            <syntax>public class NamingConvention : <see href="http://docs.unity3d.com/ScriptReference/ScriptableObject.html">ScriptableObject</see>, <see cref="T:DynamicLoadingKit.INamingConvention" href="INamingConvention.html">INamingConvention</see></syntax>
        </member>
        <member name="P:DynamicLoadingKit.NamingConvention.Format">
            <summary>
            Gets the format of the naming convention. This describes the format of the text following the 
            group name of the terrain or object (the group name is the name common to all objects/terrain in the same group).
            <para>
            When setting the format, keep in mind that %x will be replaced by the column number of the object/terrain, %y will be 
            replaced by the row number, and %z will be replaced by the layer number. All other characters will be interpreted literally.
            </para>
            </summary>
            <type>string</type>
        </member>
        <member name="P:DynamicLoadingKit.NamingConvention.NumberingStartsAt0">
            <summary>
            Gets a value indicating whether the naming convention calls for row/column/layer numbers to start at 0.
            If false, the numbers will start at 1 instead.
            </summary>
            <type>bool</type>
        </member>
        <member name="T:DynamicLoadingKit.PersistentDataController">
            <summary>
            Provides a base implementation for Persistent Data Controllers. These components control how data is saved and loaded
            between game sessions.
            <para>In order to utilize some of the inspector options (such as the ability to clear persistent data) when creating your own class which derives from PersistentDataController, you will need to create a custom inspector for your
            custom class. Please follow the template in the EditorTemplates.txt file 
            (found in the "TerrainSlicing/OtherScripts/DynamicLoadingScripts/Editor" folder) when creating this editor script.</para>
            </summary>
            <title>PersistentDataController Abstract Class</title>
            <category>Primary Components</category>
            <navigationName>PersistentDataController</navigationName>
            <fileName>PersistentDataController.html</fileName>
            <syntax>public abstract class PersistentDataController : MonoBehaviour</syntax>
            <inspector name ="Active Grid ID" type="int">The ID of the Active Grid whose data should be cleared when the "Clear Data" button is pressed. This option 
            is hidden with some Clear Methods.</inspector>
            <inspector name ="Clear All Persistent Scene Data" type="Button">Clears all persistent scene data related to
            this Persistent Data Controller. This will effectively "reset" your scene and should be used with caution.</inspector>
            <inspector name ="Clear Data" type="Button">Clears the persistent data in relation to the current "Clear Method" and ID's.</inspector>
            <inspector name ="Clear Method" type="Dropdown">The clear operation that will take place when the "Clear Data" button is pressed. Select 
            a method and hover over it to see more information about it.</inspector>
            <inspector name ="Component Manager ID" type="int">The ID of the Component Manager whose data should be cleared when the "Clear Data" button is pressed. This option 
            is hidden with some Clear Methods.
            <para>As there should only ever be one Component Manager in your scene at a time, it is unlikely that you will need to change this value.</para></inspector>
            <inspector name ="Scene ID" type="string">A unique string ID that identifies this Persistent Data Controller. The Component Manager, which initiates all
            persistent data saving/loading in the DLK, automatically prepends this ID to every key passed to the Persistent Data Controller. This allows
            Component Manager's and Active Grids in different scenes to utilize the same ID.
            <para>Persistent Data Controllers in different scenes MUST HAVE different ID's.</para></inspector>
        </member>
        <member name="P:DynamicLoadingKit.PersistentDataController.SceneID">
            <summary>
            Gets the Scene ID of this Persistent Data Controller
            </summary>
            <type>string</type>
        </member>
        <member name="M:DynamicLoadingKit.PersistentDataController.SaveData(System.String,System.String)">
            <summary>
            When overridden by a derived class, saves the specified data using the specified key.
            </summary>
            <param name="key" type="string">The key used to save the persistent data.</param>
            <param name="data" type="string">The persistent data that will be saved.</param>
            <displayName id="SaveData">SaveData(string, string)</displayName>
            <syntax>public abstract void SaveData(string key, string data)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.PersistentDataController.TryGetData(System.String,System.String@)">
            <summary>
            When overridden by a derived class, attempts to get the persistent data associated with the specified key.
            </summary>
            <param name="key" type="string">The key used to try and retrieve the persistent data.</param>
            <param name="data" type="out string">A string which will contain the data if successfully retrieved.</param>
            <returns type="bool">A value indicating whether the data was successfully retrieved. If false, "data" will be null.</returns>
            <displayName id="TryGetData">TryGetData(string, out string)</displayName>
            <syntax>public abstract bool TryGetData(string key, out string data)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.PersistentDataController.TryDeleteData(System.String)">
            <summary>
            When overridden by a derived class, attempts to delete the persistent data associated with the specified key.
            </summary>
            <param name="key" type="string">The key used to identify the persistent data that should be deleted.</param>
            <returns type ="bool">A value indicating whether the persistent data was successfully deleted.</returns>
            <displayName id="TryDeleteData">TryDeleteData(string)</displayName>
            <syntax>public abstract bool TryDeleteData(string key)</syntax>
        </member>
        <member name="T:DynamicLoadingKit.CellPlayerIsInChangedEventArgs">
            <summary>
            Event Args for CellPlyerIsInChanged event (an event of the Active Grid class).
            </summary>
            <title>CellPlayerIsInChangedEventArgs Class</title>
            <category>Other Classes</category>
            <navigationName>CellPlayerIsInChangedEventArgs</navigationName>
            <fileName>CellPlayerIsInChangedEventArgs.html</fileName>
            <syntax>public class CellPlayerIsInChangedEventArgs : EventArgs</syntax>
        </member>
        <member name="P:DynamicLoadingKit.CellPlayerIsInChangedEventArgs.WorldCellPlayerIsIn">
            <summary>
            Gets the World Cell the player is currently in, if one exists. A World Cell exists only 
            when the World has objects loaded for that cell.
            </summary>
            <type link="WorldCell.html">WorldCell</type>
        </member>
        <member name="P:DynamicLoadingKit.CellPlayerIsInChangedEventArgs.EndlessGridCellPlayerIsIn">
            <summary>
            Gets the cell the player is in as projected on an endless grid of cells.
            </summary>
            <type link="Cell.html">Cell</type>
        </member>
        <member name="P:DynamicLoadingKit.CellPlayerIsInChangedEventArgs.WorldGridCellPlayerIsIn">
            <summary>
            Gets the cell the player is in as it lies on the world grid associated with the World.
            </summary>
            <type link="Cell.html">Cell</type>
        </member>
        <member name="P:DynamicLoadingKit.CellPlayerIsInChangedEventArgs.ReasonForNullWorldCell">
            <summary>
            When WorldCellPlayerIsIn is null, this property can be used to get the reason for why it is null, 
            which can be useful for debugging purposes.
            </summary>
            <type>string</type>
        </member>
        <member name="T:DynamicLoadingKit.PlayerMovedByGridEventArgs">
            <summary>
            Event Args for a PlayerMovedByGrid event (an event of the Active Grid class).
            </summary>
            <title>PlayerMovedByGridEventArgs Class</title>
            <category>Other Classes</category>
            <navigationName>PlayerMovedByGridEventArgs</navigationName>
            <fileName>PlayerMovedByGridEventArgs.html</fileName>
            <syntax>public class PlayerMovedByGridEventArgs : EventArgs</syntax>
        </member>
        <member name="P:DynamicLoadingKit.PlayerMovedByGridEventArgs.Player">
            <summary>
            Gets the Transform of the player that was moved by the Active Grid.
            </summary>
            <type>Transform</type>
        </member>
        <member name="M:DynamicLoadingKit.PlayerMovedByGridEventArgs.#ctor(UnityEngine.Transform)">
            <summary>
            Initializes a new instance of the PlayerMovedByGridEventArgs class with the passed in player Transform.
            </summary>
            <param name="player" type="Transform">The player that was moved.</param>
            <displayName id="PlayerMovedByGridEventArgs">PlayerMovedByGridEventArgs(Transform)</displayName>
            <syntax>public PlayerMovedByGridEventArgs(Transform player)</syntax>
        </member>
        <member name="T:DynamicLoadingKit.WorldSyncedToChangedEventArgs">
            <summary>
            Event Args for a WorldSyncedToChanged event (an event of the Active Grid class).
            </summary>
            <title>WorldSyncedToChangedEventArgs Class</title>
            <category>Other Classes</category>
            <navigationName>WorldSyncedToChangedEventArgs</navigationName>
            <fileName>WorldSyncedToChangedEventArgs.html</fileName>
            <syntax>public class WorldSyncedToChangedEventArgs : EventArgs</syntax>
        </member>
        <member name="P:DynamicLoadingKit.WorldSyncedToChangedEventArgs.OldWorld">
            <summary>
            Gets the old World tha the Active Grid was synced to.
            </summary>
            <type link="World.html">World</type>
        </member>
        <member name="P:DynamicLoadingKit.WorldSyncedToChangedEventArgs.NewWorld">
            <summary>
            Gets the new World that the Active Grid is now synced to.
            </summary>
            <type link="World.html">World</type>
        </member>
        <member name="M:DynamicLoadingKit.WorldSyncedToChangedEventArgs.#ctor(DynamicLoadingKit.World,DynamicLoadingKit.World)">
            <summary>
            Initializes a new instance of the WorldSyncedToChangedEventArgs class using and old and new World.
            </summary>
            <param name="oldWorld" type="World" link="World.html">The old world the Active Grid was synced to before the change.</param>
            <param name="newWorld" type="World" link="World.html">The new world the Active Grid is synced to after the change.</param>
            <displayName id="WorldSyncedToChangedEventArgs">WorldSyncedToChangedEventArgs(World, World)</displayName>
            <syntax>public WorldSyncedToChangedEventArgs(World oldWorld, World newWorld)</syntax>
        </member>
        <member name="T:DynamicLoadingKit.PlayerMover">
            <summary>
            Provides a base implementation for Player Movers.
            <para>
            Player Movers are used when an Active Grid needs to move the player associated with it, for instance when
            the grid is moved in response to a World Shift or when 
            <see cref="M:DynamicLoadingKit.ActiveGrid.TryMovePlayerToLocation(UnityEngine.Vector3,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Single)" href="ActiveGrid.html#TryMovePlayerToLocation">TryMovePlayerToLocation</see> 
            is called.
            </para>
            <para>
            If no PlayerMover is provided to the Active Grid, then the player is moved by simply adjusting its Transform.position. 
            Depending on your movement system, however, it may be unwise to move the player in this way, as it can de-sync the player 
            from the physics system and cause issues (such as the player falling through the world).
            </para>
            <para>
            For this reason, you can create a custom script or modify an existing script to derive from PlayerMover and implement 
            the required methods in a way that works with your movement scheme.
            </para>
            <para>
            For instance, a sample script is provided in the "TerrainSlicing/OtherScripts/DynamicLoadingScripts/PlayerMoverControllers" 
            folder called PlayerMoverCharacterMotor. This script is an extended version of the default CharacterMotor script 
            included with Unity's Standard Assets, and can be used with a CharacterController component. In fact, if 
            using a CharacterController component in your movement scheme, it is imperative that you use this custom script, 
            as the player WILL fall through the world otherwise. A PlayerMoverFPSInputController script is also provided, 
            which was adjusted to use the PlayerMoverCharacterMotor script rather than the default CharacterMotor script.
            </para>
            <para>
            In order to save the player's position correctly, the Active Grid needs to know exactly when the player's position has been changed 
            by your implementation. Please refer to the PlayerMoved property for more information.
            </para>
            </summary>
            <title>PlayerMover Abstract Class</title>
            <category>Secondary Components</category>
            <navigationName>PlayerMover</navigationName>
            <fileName>PlayerMover.html</fileName>
            <syntax>public abstract class PlayerMover : MonoBehaviour</syntax>
        </member>
        <member name="P:DynamicLoadingKit.PlayerMover.PlayerMoved">
            <summary>
            When implemented in a derived class, should return a value indicating whether the Player Mover has successfully moved 
            the player. If your MovePlayerByAmount or MovePlayerToPosition method is running and the player has not been moved yet, 
            this property should return false. Once you move the player, it should return true.
            <para>
            If you end your method (yield break) IMMEDIATELY after changing the player's position, then this property should always return false.
            </para>
            <para>
            If you change the player's position immediately after the coroutine starts (i.e., before the first yield return statement), 
            you can have this property always return true.
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="M:DynamicLoadingKit.PlayerMover.MovePlayerByAmount(UnityEngine.Transform,UnityEngine.Vector3)">
            <summary>
            When override in a derived class, moves the player transform specified by the Vector3 amount. That is, the amountToMovePlayer is
            simply added to the existing player's position.
            </summary>
            <param name="player" type="Transform">The player transform that will be moved.</param>
            <param name="amountToMovePlayer" type="Vector3">The amount the player will be moved (the amount to add to the player's current position).</param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.</returns>
            <displayName id="MovePlayerByAmount">MovePlayerByAmount(Transform, Vector3)</displayName>
            <syntax>public abstract IEnumerator&lt;YieldInstruction&gt; MovePlayerByAmount(Transform player, Vector3 amountToMovePlayer)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.PlayerMover.MovePlayerToPosition(UnityEngine.Transform,UnityEngine.Vector3)">
            <summary>
            When override in a derived class, moves the player transform specified to the specified position in world space.
            </summary>
            <param name="player" type="Transform">The player transform that will be moved.</param>
            <param name="position" type="Vector3">The position the player will be moved to.</param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.</returns>
            <displayName id="MovePlayerToPosition">MovePlayerToPosition(Transform, Vector3)</displayName>
            <syntax>public abstract IEnumerator&lt;YieldInstruction&gt; MovePlayerToPosition(Transform player, Vector3 position)</syntax>
        </member>
        <member name="T:DynamicLoadingKit.PrefabInstantiatorAsync">
            <summary>
            A Cell Object Loader which loads cell object prefabs into the scene via the 
            <see href="http://docs.unity3d.com/ScriptReference/Resources.LoadAsync.html">Resources.LoadAsync</see> and 
            <see href="http://docs.unity3d.com/ScriptReference/Object.Instantiate.html">Object.Instantiate</see>
            methods.
            <para>
            When using this component, it's imperative that your prefabs be located directly in a 
            folder named "Resources" (can't be in subfolders).
            </para>
            <para>
            You should never have to interact directly with this component, as the methods/properties are called/used
            as needed by the Dynamic Loading Kit.
            </para>
            </summary>
            <title>PrefabInstantiatorAsync Class</title>
            <category>Cell Object Loaders</category>
            <navigationName>PrefabInstantiatorAsync</navigationName>
            <fileName>PrefabInstantiatorAsync.html</fileName>
            <syntax>public class PrefabInstantiatorAsync : <see cref = "T:DynamicLoadingKit.CellObjectLoader" href = "CellObjectLoader.html">CellObjectLoader</see></syntax>
        </member>
        <member name="P:DynamicLoadingKit.PrefabInstantiatorAsync.IsSingleFrameAttachmentPreloadRequired">
            <summary>
            Because Instantiated prefabs do not need a frame to "process", pre-loading is not required, and so this
            property is overridden to return false.
            </summary>
            <type>bool</type>
        </member>
        <member name="M:DynamicLoadingKit.PrefabInstantiatorAsync.AttachCellObjectsToCellsInSingleFrame``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Instantiates and attaches all cell objects to the input cells in a single frame. This is not very performant and so should only
            be used in Awake or Start.
            </summary>
            <typeparam name="T">The type of the cells.</typeparam>
            <param name="cells" type = "List&lt;T&gt;">The cells whose objects need to be attached.</param>
            <param name="loaderID" type = "int">The ID of the user requesting the attached.</param>
            <displayName id = "AttachCellObjectsToCellsInSingleFrame">AttachCellObjectsToCellsInSingleFrame&lt;T&gt;(List&lt;T&gt;, int)</displayName>
            <syntax>public sealed override void AttachCellObjectsToCellsInSingleFrame&lt;T&gt;(List&lt;T&gt; cells, int loaderID)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.PrefabInstantiatorAsync.LoadAndAttachCellObjectsToCells``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Loads and attaches the objects associated with the input cells to the cells over a period of frames.
            After each Instantiation, if "Time To Yield Between Instantiates" is greater than 0, that amount of time is yielded.
            </summary>
            <typeparam name="T">The type of the cells.</typeparam>
            <param name="cells" type = "List&lt;T&gt;">The cells whose objects need to be loaded and attached.</param>
            <param name="loaderID" type = "int">The ID of the user requesting the load and attachment.</param>
            <displayName id = "AttachCellObjectsToCellsInSingleFrame">LoadAndAttachCellObjectsToCells&lt;T&gt;(List&lt;T&gt;, int)</displayName>
            <syntax>public sealed override IEnumerator&lt;YieldInstruction&gt; AttachCellObjectsToCellsInSingleFrame&lt;T&gt;(List&lt;T&gt; cells, int loaderID)</syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.</returns>
        </member>
        <member name="T:DynamicLoadingKit.RegistrationHandler`1">
            <summary>
            Handles the registration of multiple users of any reference type. 
            </summary>
            <title>RegistrationHandler&lt;T&gt; Class</title>
            <category>Other Classes</category>
            <navigationName>RegistrationHandler</navigationName>
            <fileName>RegistrationHandler.html</fileName>
            <syntax>public class RegistrationHandler&lt;T&gt; where T : class</syntax>
        </member>
        <member name="M:DynamicLoadingKit.RegistrationHandler`1.#ctor">
            <summary>
            Initializes a new instance of the RegistrationHandler class, with a default capacity of 4.
            </summary>
            <displayName id = "RegistrationHandler1">RegistrationHandler()</displayName>
            <syntax>public RegistrationHandler()</syntax>
        </member>
        <member name="M:DynamicLoadingKit.RegistrationHandler`1.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the RegistrationHandler class, with a capacity of intitialCapacity.
            </summary>
            <param name="intitialCapacity" type = "int">The initial capacity of the registration handler. If a user is registered
            when there is no more room, the capacity will be doubled.</param>
            <displayName id ="RegistrationHandler2">RegistrationHandler(int)</displayName>
            <syntax>public RegistrationHandler(int intitialCapacity)</syntax>
        </member>
        <member name="P:DynamicLoadingKit.RegistrationHandler`1.LastValidID">
            <type>int</type>
            <summary>
            Gets a value reflecting the last valid ID in the current registrar. Valid ID's range from 0 to LastValidID.
            Note that this is a reflection of the current possible registrants, not the max allowed registrants.
            The main use of this is for validating ID's you are not sure are valid, since trying to access a registrant with an invalid ID will
            cause all sorts of trouble.
            </summary>
        </member>
        <member name="P:DynamicLoadingKit.RegistrationHandler`1.Item(System.Int32)">
            <type>T</type>
            <summary>
            Gets the user T associated with the specified registrationID.
            </summary>
        </member>
        <member name="P:DynamicLoadingKit.RegistrationHandler`1.RegistrantsExists">
            <summary>
            Gets a value indicating whether any users are registered.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DynamicLoadingKit.RegistrationHandler`1.RegistrantsRegistered">
            <summary>
            Gets a value indicating how many users are registered.
            </summary>
            <type>int</type>
        </member>
        <member name="M:DynamicLoadingKit.RegistrationHandler`1.AddRegistrant(`0,System.Int32@)">
            <summary>
            Add a new registrant.
            </summary>
            <param name="newRegistrant" type = "T">The registrant to add.</param>
            <param name="registrationID" type = "out int">The ID assigned to the new registrant. Use this value when
            you wish to retrieve the registrant.</param>
            <displayName id = "AddRegistrant">AddRegistrant(T, out int)</displayName>
            <syntax>public void AddRegistrant(T newRegistrant, out int registrationID)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.RegistrationHandler`1.RemoveRegistrant(System.Int32)">
            <summary>
            Remove the registrant registered under registrationID.
            </summary>
            <param name="registrationID" type ="int">The ID of the registrant to remove.</param>
            <displayName id = "RemoveRegistrant">RemoveRegistrant(int)</displayName>
            <syntax>public void RemoveRegistrant(int registrationID)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.RegistrationHandler`1.GetAllRegistrants(System.Collections.Generic.List{`0})">
            <summary>
            Gets all the users currently registered.
            </summary>
            <displayName id="GetAllRegistrants">GetAllRegistrants(List&lt;T&gt;)</displayName>
            <syntax>public void GetAllRegistrants(List&lt;T&gt; registrants)</syntax>
            <param name="registrants" type="List&lt;T&gt;">The list the registrants will be added to.</param>
        </member>
        <member name="M:DynamicLoadingKit.RegistrationHandler`1.GetAllRegistrantsOfType``1(System.Collections.Generic.List{``0})">
            <summary>
            Gets all the users currently registered of the type U specified.
            </summary>
            <typeparam name="U">The specific type of the registrant to get. Must be or derive from T</typeparam>
            <param name="registrants" type="List&lt;U&gt;">The list to add the registrants to.</param>
            <displayName id="GetAllRegistrantsOfType">GetAllRegistrantsOfType&lt;U&gt;(List&lt;U&gt;)</displayName>
            <syntax>public void GetAllRegistrantsOfType&lt;U&gt;(List&lt;U&gt; registrants) where U : T</syntax>
        </member>
        <member name="M:DynamicLoadingKit.RegistrationHandler`1.RegistrantEntries">
            <summary>
            Gets an enumerable collection of registered users. This can be used in a foreach.
            </summary>
            <returns type="IEnumerable&lt;T&gt;">An enumerable collection of the registered users.</returns>
            <example>
            <code>
            class IterateOverRegistrantsExample
            {
                RegistrationHandler&lt;ActiveGrid&gt; activeGridUsers;
                
                public void Iterate()
                {
                    foreach(ActiveGrid activeGrid in activeGridUsers.RegistrantEntries())
                        activeGrid.DoSomething();
                }
            }
            </code>
            </example>
            <displayName id="RegistrantEntries">RegistrantEntries()</displayName>
            <syntax>public IEnumerable&lt;T&gt; RegistrantEntries()</syntax>
        </member>
        <member name="T:DynamicLoadingKit.Cell">
            <summary>
            Represents a cell on a grid.
            </summary>
            <title>Cell Structure</title>
            <category>Structs</category>
            <navigationName>Cell</navigationName>
            <fileName>Cell.html</fileName>
            <syntax>public struct Cell</syntax>
        </member>
        <member name="M:DynamicLoadingKit.Cell.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the Cell structure.
            </summary>
            <param name="row" type="int">The row index of the cell.</param>
            <param name="column" type="int">The column index of the cell.</param>
            <param name="layer" type="int">The layer index of the cell. Only needed when the cell is associated with a three dimensional entity, otherwise just pass in 1.</param>
            <displayName id="Cell">Cell(int, int, int)</displayName>
            <syntax>public Cell(int row, int column, int layer)</syntax>
        </member>
        <member name="P:DynamicLoadingKit.Cell.Column">
            <summary>
            Gets the column index of the cell.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DynamicLoadingKit.Cell.Layer">
            <summary>
            Gets the layer index of the cell.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DynamicLoadingKit.Cell.Row">
            <summary>
            Gets the row index of the cell.
            </summary>
            <type>int</type>
        </member>
        <member name="M:DynamicLoadingKit.Cell.ToString">
            <summary>
            Returns a nicely formatted string representation of the Cell's Indexes.
            </summary>
            <displayName id="ToString">ToString()</displayName>
            <syntax>public override string ToString()</syntax>
            <returns>A string representation of the Cell's Indexes.</returns>
        </member>
        <member name="T:DynamicLoadingKit.CellDimensions">
            <summary>
            Represents the dimensions of a <see cref="T:DynamicLoadingKit.Cell" href="Cell.html">Cell</see>.
            </summary>
            <title>CellDimensions Structure</title>
            <category>Structs</category>
            <navigationName>CellDimensions</navigationName>
            <fileName>CellDimensions.html</fileName>
            <syntax>public struct CellDimensions</syntax>
        </member>
        <member name="F:DynamicLoadingKit.CellDimensions.height">
            <summary>
            The height of the cell. This is only relevant when the cell in question is associated with a three dimensional entity.
            </summary>
            <type>readonly float</type>
            <defaultValue>Does Not Apply</defaultValue>
        </member>
        <member name="F:DynamicLoadingKit.CellDimensions.length">
            <summary>
            The length of the cell.
            </summary>
            <type>readonly float</type>
            <defaultValue>Does Not Apply</defaultValue>
        </member>
        <member name="F:DynamicLoadingKit.CellDimensions.width">
            <summary>
            The width of the cell.
            </summary>
            <type>readonly float</type>
            <defaultValue>Does Not Apply</defaultValue>
        </member>
        <member name="M:DynamicLoadingKit.CellDimensions.#ctor(System.Single,System.Single)">
            <summary>
            Initializes a new instance of the CellDimension structure with height set to 0.
            </summary>
            <param name="length" type="float">The length of the cell.</param>
            <param name="width" type="float">The width of the cell.</param>
            <displayName id="">CellDimensions(float, float)</displayName>
            <syntax>public CellDimensions(float length, float width)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.CellDimensions.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the CellDimension structure.
            </summary>
            <param name="height" type="float">The height of the cell. This is only relevant when the cell in question is associated with a three dimensional entity.</param>
            <param name="length" type="float">The length of the cell.</param>
            <param name="width" type="float">The width of the cell.</param>
            <displayName id="">CellDimensions(float, float, float)</displayName>
            <syntax>public CellDimensions(float height, float length, float width)</syntax>
        </member>
        <member name="T:DynamicLoadingKit.GridValues`1">
            <summary>
            Represents a generic collection of values for a row, column, and layer. This class is used internally in several areas, but you will 
            probably never need to use it yourself, unless you are writing some custom code and want the convenience it offers.
            </summary>
            <title>GridValues&lt;T&gt; Structure</title>
            <category>Structs</category>
            <navigationName>GridValues</navigationName>
            <fileName>GridValues.html</fileName>
            <syntax>public struct GridValues&lt;T&gt;</syntax>
        </member>
        <member name="F:DynamicLoadingKit.GridValues`1.columnValue">
            <summary>
            The column value.
            </summary>
            <type>readonly T</type>
            <defaultValue>Does Not Apply</defaultValue>
        </member>
        <member name="F:DynamicLoadingKit.GridValues`1.layerValue">
            <summary>
            The layer value.
            </summary>
            <type>readonly T</type>
            <defaultValue>Does Not Apply</defaultValue>
        </member>
        <member name="F:DynamicLoadingKit.GridValues`1.rowValue">
            <summary>
            The row value.
            </summary>
            <type>readonly T</type>
            <defaultValue>Does Not Apply</defaultValue>
        </member>
        <member name="M:DynamicLoadingKit.GridValues`1.#ctor(`0,`0,`0)">
            <summary>
            Initializes a new instance of the GridValues structure.
            </summary>
            <param name="layerValue" type = "T">The layer value that the structure should hold.</param>
            <param name="rowValue" type = "T">The row value that the structure should hold.</param>
            <param name="columnValue" type = "T">The column value that the structure should hold.</param>
            <displayName id="">GridValues(T, T, T)</displayName>
            <syntax>public GridValues(T layerValue, T rowValue, T columnValue)</syntax>
        </member>
        <member name="T:DynamicLoadingKit.ActiveGridDimensions">
            <summary>
            Represents the dimensions of an <see cref="T:DynamicLoadingKit.ActiveGrid" href="ActiveGrid.html">Active Grid</see>.
            </summary>
            <title>ActiveGridDimensions Structure</title>
            <category>Structs</category>
            <navigationName>ActiveGridDimensions</navigationName>
            <fileName>ActiveGridDimensions.html</fileName>
            <syntax>public struct ActiveGridDimensions</syntax>
        </member>
        <member name="F:DynamicLoadingKit.ActiveGridDimensions.innerAreaColumns">
            <summary>
            The number of columns in the inner area of the Active Grid.
            </summary>
            <type>readonly int</type>
            <defaultValue>Does Not Apply</defaultValue>
        </member>
        <member name="F:DynamicLoadingKit.ActiveGridDimensions.innerAreaLayers">
            <summary>
            The number of layers in the inner area of the Active Grid. Only relevant when the grid is associated with a three dimensional World or other entity.
            </summary>
            <type>readonly int</type>
            <defaultValue>Does Not Apply</defaultValue>
        </member>
        <member name="F:DynamicLoadingKit.ActiveGridDimensions.innerAreaRows">
            <summary>
            The number of rows in the inner area of the Active Grid.
            </summary>
            <type>readonly int</type>
            <defaultValue>Does Not Apply</defaultValue>
        </member>
        <member name="F:DynamicLoadingKit.ActiveGridDimensions.outerRingWidth">
            <summary>
            The width of the ring of cells that surrounds the inner area of the Active Grid.
            </summary>
            <type>readonly int</type>
            <defaultValue>Does Not Apply</defaultValue>
        </member>
        <member name="M:DynamicLoadingKit.ActiveGridDimensions.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the ActiveGridDimensions structure.
            </summary>
            <param name="innerAreaLayers" type="int">The number of layers in the inner area of the Active Grid. Only relevant when the grid is associated with a three dimensional World or other entity.</param>
            <param name="innerAreaRows" type="int">The number of rows in the inner area of the Active Grid.</param>
            <param name="innerAreaColumns" type="int">The number of columns in the inner area of the Active Grid.</param>
            <param name="outerRingWidth" type="int">The width of the ring of cells that surrounds the inner area of the Active Grid.</param>
            <displayName id="">ActiveGridDimensions(int, int, int, int)</displayName>
            <syntax>public ActiveGridDimensions(int innerAreaLayers, int innerAreaRows, int innerAreaColumns, int outerRingWidth)</syntax>
        </member>
        <member name="T:DynamicLoadingKit.ActiveGridType">
            <summary>
            Specifies the type of an <see cref="T:DynamicLoadingKit.ActiveGrid" href="ActiveGrid.html">Active Grid</see>.
            </summary>
            <title>ActiveGridType Enumeration</title>
            <category>Enums</category>
            <navigationName>ActiveGridType</navigationName>
            <fileName>ActiveGridType.html</fileName>
            <syntax>public enum ActiveGridType</syntax>
            <enumMember name="Outer_Ring_Grid">
            An Active Grid with an outer grid. The loaded cells include the inner grid (one ore more whole cells)
            and one or more rings of cells representing the outer grid.
            A minimum of 9 cells will be loaded at a time.
            </enumMember>
            <enumMember name="Sectioned_Grid">
            An Active Grid with a cell divided into four equal sections. The inner grid is the sectioned cell the player 
            is currently in. The loaded cells include the cell the inner grid is in, as well as the 3 cells that are "touching" 
            the inner grid. 4 (for 2D worlds) or 8 (for 3D worlds) cells will be loaded at a time.
            </enumMember>
        </member>
        <member name="T:DynamicLoadingKit.BoundaryCrossed">
            <summary>
            Specifies which boundary was crossed by a tracked entity.
            <para>For 2D worlds, there are four boundaries (West, East, North, and South). Together these boundaries form a rectangle.
            For XZ worlds, this rectangle lies on the XZ plane, with the West boundary having the lowest X value and South boundary having
            the lowest Z value.</para>
            <para>For XY worlds, the West boundary still has the lowest X value, but the South boundary instead has the lowest Y value.</para>
            <para>For 3D worlds, the Top and Bottom boundaries are also used, forming a cube rather than a rectangle. The West and East are the
            boundaries with the lowest and highest X values respectively, the South and North are the boundaries with the lowest and highest
            Z values respectively, and the Bottom and Top are the boundaries with the lowest and highest Y values respectively.</para>
            </summary>
            <title>BoundaryCrossed Enumeration</title>
            <category>Enums</category>
            <navigationName>BoundaryCrossed</navigationName>
            <fileName>BoundaryCrossed.html</fileName>
            <syntax>public enum BoundaryCrossed</syntax>
            <enumMember name ="None">No boundary was crossed.</enumMember>
            <enumMember name ="West">West boundary was crossed.</enumMember>
            <enumMember name ="East">East boundary was crossed.</enumMember>
            <enumMember name ="North">North boundary was crossed.</enumMember>
            <enumMember name ="South">South boundary was crossed.</enumMember>
            <enumMember name ="Top">Top boundary was crossed (Only relevant when using 3D world).</enumMember>
            <enumMember name ="Bottom">Bottom boundary was crossed (Only relevant when using 3D world).</enumMember>
        </member>
        <member name="T:DynamicLoadingKit.CellObjectType">
            <summary>
            Specifies object types for the cell objects used in the Dynamic Loading Kit.
            </summary>
            <title>CellObjectType Enumeration</title>
            <category>Enums</category>
            <navigationName>CellObjectType</navigationName>
            <fileName>CellObjectType.html</fileName>
            <syntax>public enum CellObjectType</syntax>
            <enumMember name ="Unity_Terrain">The objects are non Unity Terrains that do not have a Renderer Component.</enumMember>
            <enumMember name ="Other_Has_Renderer">The objects are Unity Terrains.</enumMember>
            <enumMember name ="Other_No_Renderer">The objects are non Unity Terrains that have a Renderer Component.</enumMember>
        </member>
        <member name="T:DynamicLoadingKit.Direction">
            <summary>
            Specifies directions on the world.
            </summary>
            <title>Direction Enumeration</title>
            <category>Enums</category>
            <navigationName>Direction</navigationName>
            <fileName>Direction.html</fileName>
            <syntax>public enum Direction</syntax>
            <enumMember name ="West">West Direction (Along Negative X Axis)</enumMember>
            <enumMember name ="East">East Direction (Along Positive X Axis).</enumMember>
            <enumMember name ="North">North Direction (Along Positive Z (For XZ Worlds) or Y (For XY Worlds) Axes).</enumMember>
            <enumMember name ="South">South Direction (Along Negative Z (For XZ Worlds) or Y (For XY Worlds) Axes).</enumMember>
            <enumMember name ="Up">Up Direction (3D worlds only Along Positive Y Axis).</enumMember>
            <enumMember name ="Down">Down Direction (3D Worlds Only Along Negative Y Axis).</enumMember>
        </member>
        <member name="T:DynamicLoadingKit.MemoryFreeingStrategy">
            <summary>
            Specifies a strategy for freeing memory.
            </summary>
            <title>MemoryFreeingStrategy Enumeration</title>
            <category>Enums</category>
            <navigationName>MemoryFreeingStrategy</navigationName>
            <fileName>MemoryFreeingStrategy.html</fileName>
            <syntax>public enum MemoryFreeingStrategy</syntax>
            <enumMember name ="Manual">Memory is not freed automatically. You have trigger it manually.</enumMember>
            <enumMember name ="Auto_UnloadUnusedResourcesOnly">Memory is freed automatically by calling the Resources.UnloadUnusedAssets method.</enumMember>
            <enumMember name ="Auto_GCCollectOnly">Memory is freed automatically by calling the System.GC.Collection method.</enumMember>
            <enumMember name ="Auto_Both">Memory is freed automatically by calling the Resources.UnloadUnusedAssets method as well as the System.GC.Collect method.</enumMember>
        </member>
        <member name="T:DynamicLoadingKit.TerrainNeighbor">
            <summary>
            Specifies the position of a terrain in relation to another terrain.
            </summary>
            <title>TerrainNeighbor Enumeration</title>
            <category>Enums</category>
            <navigationName>TerrainNeighbor</navigationName>
            <fileName>TerrainNeighbor.html</fileName>
            <syntax>public enum TerrainNeighbor</syntax>
            
            <enumMember name ="Left">The terrain neighbor is to the left of the base terrain (along the X Axis).</enumMember>
            <enumMember name ="Top">The terrain neighbor is above the base terrain (along the Z Axis).</enumMember>
            <enumMember name ="Right">The terrain neighbor is to the right of the base terrain (along the X Axis).</enumMember>
            <enumMember name ="Bottom">The terrain neighbor is below the base terrain (along the Z Axis).</enumMember>
        </member>
        <member name="T:DynamicLoadingKit.WorldType">
            <summary>
            Specifies a type of world a World Grid (and the objects associated with that grid) is meant for.
            </summary>
            <title>WorldType Enumeration</title>
            <category>Enums</category>
            <navigationName>WorldType</navigationName>
            <fileName>WorldType.html</fileName>
            <syntax>public enum WorldType</syntax>
            <enumMember name ="Two_Dimensional_On_XY_Axes">A world with two dimensions. Columns are on the X axis while rows are on the Y axis (2D side scrolling games anyone?).</enumMember>
            <enumMember name ="Two_Dimensional_On_XZ_Axes">A world with two dimensions. Columns are on the X Axis while rows are on the Z Axis.</enumMember>
            <enumMember name ="Three_Dimensional">A world with three dimensions.
            <para>Columns are on the X axis, rows on the Z axis, and layers on the Y axis.</para></enumMember>
        </member>
        <member name="T:DynamicLoadingKit.WorldState">
            <summary>
            Specifies the state of a <see cref="T:DynamicLoadingKit.World" href="World.html">World</see>.
            </summary>
            <title>WorldState Enumeration</title>
            <category>Enums</category>
            <navigationName>WorldState</navigationName>
            <fileName>WorldState.html</fileName>
            <syntax>public enum WorldState</syntax>
            <enumMember name ="Uninitialized">
            The initial state of the World, before it has been initialized by a component manager. If creating the world via 
            one of the component manager's create world methods, the world will never be in this state, since the component manager automatically 
            initializes the world when it is created.
            </enumMember>
            <enumMember name ="Idle">
            The state of the World after Initialization, while the world has no registered users and/or cell user request. Once the world exits the Idle 
            state, it will only enter it again if all users registered with the World unregister with it.
            </enumMember>
            <enumMember name ="WaitingForRequest">
            Standard phase when the World has no cell user add/remove request to process. Note that this is different than idle. While idle, 
            the World's update loop is suspended. In the WaitingForRequest state, the update loop is running (checking whether any new 
            requests have been received).
            </enumMember>
             <enumMember name ="ProcessingRequest">
            The World enters this state when it has received cell user add and/or remove request. In this state, duplicate and/or offsetting 
            request are removed.
            </enumMember>
            <enumMember name ="UpdatingWorldWithoutShift">
            The World enters this state after processing a batch of cell user add/remove request, when at least one request
            survives the processing phase, and no origin shift is needed. In this state, objects are removed/added from the scene as needed.
            </enumMember>
            <enumMember name ="UpdatingWorldWithShift">
            The World enters this state after processing a batch of cell user add/remove request, when at least one request
            survives the processing phase, and an origin shift is needed. In this state, objects are removed/added from the scene as needed while 
            the origin shift is simultaneously processed. During this state any Active Grids registered with the World are notified so they can 
            enter a 'busy' state until the shift is complete.
            </enumMember>
            <enumMember name ="UpdatingWorldWithExplicitOriginCellUpdate">
            The World enters this state after processing a batch of cell user add/remove request, when at least one request
            survives the processing phase, and an expicit origin cell update has been requested. In this state, objects are removed/added from the scene 
            as needed, while the origin cell is simultaneously updated. This only occurs when you use the 
            <see cref="M:DynamicLoadingKit.ActiveGrid.TryMakeCellOriginCell(DynamicLoadingKit.Cell,System.Boolean,System.Boolean,System.Nullable{UnityEngine.Vector3},System.Boolean,System.Single,System.Boolean)" href="ActiveGrid.html#TryMakeCellOriginCell">TryMakeCellOriginCell</see> method of the Active Grid 
            component. During this state any Active Grids registered with the World are notified so they can 
            enter a 'busy' state until the cell update is complete.
            </enumMember>
            <enumMember name ="CompletingWorldShift">
            The World enters this state after updating the origin cell (either explicitly or via an origin shift). During this state, the world 
            notifies any registered users that an origin shift or explicit update has occured. Active Grids receive a special notification that triggers 
            the change in position of the player associated with the Active Grid. The active grids also exit their 'busy' state at this time so other 
            multi-frame actions can be called.
            </enumMember>
        </member>
        <member name="T:DynamicLoadingKit.DuplicateIDException">
            <summary>
            The exception that is thrown when multiple components of the same type in the same scene have the same ID.
            </summary>
            <title>DuplicateIDException Class</title>
            <category>Exceptions</category>
            <navigationName>DuplicateIDException</navigationName>
            <fileName>DuplicateIDException.html</fileName>
            <syntax>public class DuplicateIDException : Exception</syntax>
        </member>
        <member name="T:DynamicLoadingKit.UninitializedActiveGridException">
            <summary>
            The exception that is thrown when an Active Grid has not been properly awoken (ManagedAwake not called successfully).
            </summary>
            <title>UninitializedActiveGridException Class</title>
            <navigationName>UninitializedActiveGridException</navigationName>
            <fileName>UninitializedActiveGridException.html</fileName>
            <syntax>public class UninitializedActiveGridException : Exception</syntax>
        </member>
        <member name="T:DynamicLoadingKit.InvalidPrototypeException">
            <summary>
            The exception that is thrown when trying to create a World or Active Grid at runtime from a prototype that does not exist.
            </summary>
            <title>InvalidPrototypeException Class</title>
            <category>Exceptions</category>
            <navigationName>InvalidPrototypeException</navigationName>
            <fileName>InvalidPrototypeException.html</fileName>
            <syntax>public class InvalidPrototypeException : Exception</syntax>
        </member>
        <member name="T:DynamicLoadingKit.InvalidSaveDataException">
            <summary>
            The exception that is thrown when the save data for a Component Manager is not valid. The save data might have been loaded 
            manually via LoadSaveData (if using a custom save/load solution) or automatically via the Persistent Data Controller.
            </summary>
            <title>InvalidSaveDataException Class</title>
            <category>Exceptions</category>
            <navigationName>InvalidSaveDataException</navigationName>
            <fileName>InvalidSaveDataException.html</fileName>
            <syntax>public class InvalidSaveDataException : Exception</syntax>
        </member>
        <member name="T:DynamicLoadingKit.InvalidIDException">
            <summary>
            The exception that is thrown when a supplied ID does not match a valid component.
            </summary>
            <title>InvalidIDException Class</title>
            <category>Exceptions</category>
            <navigationName>InvalidIDException</navigationName>
            <fileName>InvalidIDException.html</fileName>
            <syntax>public class InvalidIDException : Exception</syntax>
        </member>
        <member name="T:DynamicLoadingKit.InvalidPersistenceException">
            <summary>
            The exception that is thrown when an attempt is made to sync a persistent 
            <see cref="T:DynamicLoadingKit.ActiveGrid" href="ActiveGrid.html">Active Grid</see> 
            to a non persistent <see cref="T:DynamicLoadingKit.World" href="World.html">World</see>.
            </summary>
            <title>InvalidPersistenceException Class</title>
            <category>Exceptions</category>
            <navigationName>InvalidPersistenceException</navigationName>
            <fileName>InvalidPersistenceException.html</fileName>
            <syntax>public class InvalidPersistenceException : Exception</syntax>
        </member>
        <member name="T:DynamicLoadingKit.RequiredComponentNotFoundException">
            <summary>
            The exception that is thrown when a required component or Scriptable Object asset are not found on a component that needs to use them.
            </summary>
            <title>RequiredComponentNotFoundException Class</title>
            <category>Exceptions</category>
            <navigationName>RequiredComponentNotFoundException</navigationName>
            <fileName>RequiredComponentNotFoundException.html</fileName>
            <syntax>public class RequiredComponentNotFoundException : Exception</syntax>
        </member>
        <member name="T:DynamicLoadingKit.UnboundCellObjectNotFoundException">
            <summary>
            The exception that is thrown when a <see cref="T:DynamicLoadingKit.BaseSceneLoader" href="BaseSceneLoader.html">Scene Loader</see> Component cannot find a newly loaded object.
            <para>This is most likely due to incorrect naming or tag setup. Please refer to the 
            <see href="http://deepspacelabs.net/files/Dynamic_Loading_Kit_Quick_Guide.pdf">Dynamic Loading Kit Quick Guide</see> for more information.</para>
            </summary>
            <title>UnboundCellObjectNotFoundException Class</title>
            <category>Exceptions</category>
            <navigationName>UnboundCellObjectNotFoundException</navigationName>
            <fileName>UnboundCellObjectNotFoundException.html</fileName>
            <syntax>public class UnboundCellObjectNotFoundException : Exception</syntax>
        </member>
        <member name="T:DynamicLoadingKit.WorldGridNotSetException">
            <summary>
            The exception that is thrown when the data of a World Grid Scriptable Object asset has not been "set" before entering Play Mode.
            </summary>
            <title>WorldGridNotSetException Class</title>
            <category>Exceptions</category>
            <navigationName>WorldGridNotSetException</navigationName>
            <fileName>WorldGridNotSetException.html</fileName>
            <syntax>public class WorldGridNotSetException : Exception</syntax>
        </member>
        <member name="T:DynamicLoadingKit.CellString">
            <summary>
            Provides a base implementation for Cell Strings.
            <para>Cell Strings are a special class of objects used in the DLK to load objects and scenes in a more efficient manner 
            (reduced garbage generation). You use the <see cref="M:DynamicLoadingKit.CellString.MatchStringToCell(DynamicLoadingKit.Cell)" href="#MatchStringToCell">MatchStringToCell(<see cref="T:DynamicLoadingKit.Cell" href="Cell.html">Cell</see>)</see> method to
            set the state of a Cell String, and then run comparisons or create string objects using the other methods.</para>
            <para>
            Now uses 1 based indexing (i.e. passing in a cell with row = 1, column = 1 creates a string of baseName_1_1).
            </para>
            </summary>
            <title>CellString Abstract Class</title>
            <category>Cell Strings</category>
            <navigationName>CellString</navigationName>
            <fileName>CellString.html</fileName>
            <syntax>public abstract class CellString</syntax>
        </member>
        <member name="F:DynamicLoadingKit.CellString.baseName">
            <summary>
            The base name of the Cell String. This should match the base name of the object group associated with your World.
            </summary>
            <type>readonly string</type>
            <defaultValue>Not Applicable</defaultValue>
        </member>
        <member name="M:DynamicLoadingKit.CellString.IsEqualTo(System.String)">
            <summary>
            Checks whether the provided string (str) matches the Cell String.
            </summary>
            <param name="str" type="string">The string to compare the Cell String to.</param>
            <displayName id = "IsEqualTo">IsEqualTo(string)</displayName>
            <syntax>public abstract bool IsEqualTo(string str)</syntax>
            <returns type = "bool">A bool indicating whether the input string matches the Cell String.</returns>
        </member>
        <member name="M:DynamicLoadingKit.CellString.MatchStringToCell(DynamicLoadingKit.Cell)">
            <summary>
            When overridden in a derived class, adjust the Cell String to match the input cell's properties.
            </summary>
            <param name="cell" type = "Cell" link = "Cell.html">The cell to match this cell string to.</param>
            <displayName id = "MatchStringToCell">MatchStringToCell(Cell)</displayName>
            <syntax>public abstract void MatchStringToCell(Cell cell)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.CellString.ToString">
            <summary>
            Rreturns a string representing the Cell String.
            </summary>
            <displayName id = "ToString">ToString()</displayName>
            <syntax>public abstract string ToString()</syntax>
            <returns type = "string">A string representing the Cell String</returns>
        </member>
        <member name="T:DynamicLoadingKit.CellString2D">
            <summary>
            A Cell String class designed to be used with two dimensional worlds.
            <para>
            You should only need to worry about this class when creating custom 
            <see cref="T:DynamicLoadingKit.CellObjectLoader" href="CellObjectLoader.html">
            Cell Object Loaders</see>,
            but if you need more information 
            about what this class is for, please visit the 
            <see cref="T:DynamicLoadingKit.CellString" href="CellString.html">CellString</see> page.
            </para>
            <para>
            Now uses 1 based indexing (i.e. passing in a cell with row = 1, column = 1 creates a string of baseName_1_1).
            </para>
            </summary>
            <title>CellString2D Class</title>
            <category>Cell Strings</category>
            <navigationName>CellString2D</navigationName>
            <fileName>CellString2D.html</fileName>
            <syntax>public class CellString2D : <see cref="T:DynamicLoadingKit.CellString" href="CellString.html">CellString</see></syntax>
        </member>
        <member name="M:DynamicLoadingKit.CellString2D.#ctor(System.String,DynamicLoadingKit.INamingConvention)">
            <summary>
            Initializes a new instance of the CellString2D with the specified baseName and naming convention.
            </summary>
            <param name="baseName" type = "string">The base name of the Cell String which will remain constant for the life of the Cell String.</param>
            <param name="namingConvention" type="INamingConvention" link="INamingConvention.html">
            The naming convention for the Cell String to use.
            </param>
            <displayName id = "CellString2D">CellString2D(string, INamingConvention)</displayName>
            <syntax>public CellString2D(string baseName, INamingConvention namingConvention)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.CellString2D.MatchStringToCell(DynamicLoadingKit.Cell)">
            <summary>
            Adjust the Cell String to match the input cell's properties (its row and column indexes).
            </summary>
            <param name="cell" type = "Cell" link = "Cell.html">The cell to match this cell string to.</param>
            <displayName id = "MatchStringToCell">MatchStringToCell(Cell)</displayName>
            <syntax>public sealed override void MatchStringToCell(Cell cell)</syntax>
        </member>
        <member name="T:DynamicLoadingKit.CellString3D">
            <summary>
            A Cell String class designed to be used with three dimensional worlds.
            <para>You should only need to worry about this class when creating custom 
            <see cref="T:DynamicLoadingKit.CellObjectLoader" href="CellObjectLoader.html">Cell Object Loaders</see>, but if you need more information 
            about what this class is for, please visit the <see cref="T:DynamicLoadingKit.CellString" href="CellString.html">CellString</see> page.</para>
            <para>
            Now uses 1 based indexing (i.e. passing in a cell with layer = 1, row = 1, column = 1 creates a string of baseName_1_1_1).
            </para>
            </summary>
            <title>CellString3D Class</title>
            <category>Cell Strings</category>
            <navigationName>CellString3D</navigationName>
            <fileName>CellString3D.html</fileName>
            <syntax>public class CellString3D : <see cref="T:DynamicLoadingKit.CellString" href="CellString.html">CellString</see></syntax>
        </member>
        <member name="M:DynamicLoadingKit.CellString3D.#ctor(System.String,DynamicLoadingKit.INamingConvention)">
            <summary>
            Initializes a new instance of the CellString3D with the specified baseName, maxLayer, maxRow, and maxColumn.
            </summary>
            <param name="baseName" type = "string">The base name of the Cell String which will remain constant for the life of the Cell String.</param>
            <param name="namingConvention" type="INamingConvention" link="INamingConvention.html">
            The naming convention for the Cell String to use.
            </param>
            <displayName id = "CellString3D">CellString3D(string, INamingConvention)</displayName>
            <syntax>public CellString3D(string baseName, INamingConvention namingConvention)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.CellString3D.MatchStringToCell(DynamicLoadingKit.Cell)">
            <summary>
            Adjust the Cell String to match the input cell's properties (its layer, row and column indexes).
            </summary>
            <param name="cell" type = "Cell" link = "Cell.html">The cell to match this cell string to.</param>
            <displayName id = "MatchStringToCell">MatchStringToCell(Cell)</displayName>
            <syntax>public sealed override void MatchStringToCell(Cell cell)</syntax>
        </member>
        <member name="T:DynamicLoadingKit.IWorldCell">
            <summary>
            Represents a cell in a <see href = "World.html">World</see>.
            </summary>
            <title>IWorldCell Interface</title>
            <category>Interfaces</category>
            <navigationName>IWorldCell</navigationName>
            <fileName>IWorldCell.html</fileName>
            <syntax>public interface IWorldCell</syntax>
        </member>
        <member name="P:DynamicLoadingKit.IWorldCell.CellOnWorldGrid">
            <summary>
            Gets the cells index on the World Grid associated with the World the cell belongs to.
            </summary>
            <type link = "Cell.html">Cell</type>
        </member>
        <member name="P:DynamicLoadingKit.IWorldCell.CellOnEndlessGrid">
            <summary>
            Gets the cells index on the Endless Grid associated with the World the cell belongs to.
            </summary>
            <type link = "Cell.html">Cell</type>
        </member>
        <member name="P:DynamicLoadingKit.IWorldCell.Height">
            <summary>
            Gets the cells height, measured along the Y axis. This will always be 0 if the world is not three dimensional.
            </summary>
            <type>float</type>
        </member>
        <member name="P:DynamicLoadingKit.IWorldCell.Length">
            <summary>
            Gets the cells length, measured along the Y axis if using a 2D XY world, or along the Z axis otherwise.
            </summary>
            <type>float</type>
        </member>
        <member name="P:DynamicLoadingKit.IWorldCell.Width">
            <summary>
            Gets the cells width, always measured along the X axis.
            </summary>
            <type>float</type>
        </member>
        <member name="P:DynamicLoadingKit.IWorldCell.CellPosition">
            <summary>
            Gets the cells position in world space.
            </summary>
            <type link = "http://docs.unity3d.com/ScriptReference/Vector3.html">Vector3</type>
        </member>
        <member name="T:DynamicLoadingKit.IAttachableWorldCell">
            <summary>
            Represents a cell in a <see href = "World.html">World</see> that can have an object "attached" to it.
            </summary>
            <title>IAttachableWorldCell Interface</title>
            <category>Interfaces</category>
            <navigationName>IAttachableWorldCell</navigationName>
            <fileName>IAttachableWorldCell.html</fileName>
            <syntax>public interface IAttachableWorldCell : <see cref="T:DynamicLoadingKit.IWorldCell" href = "IWorldCell.html">IWorldCell</see></syntax>
        </member>
        <member name="P:DynamicLoadingKit.IAttachableWorldCell.CellObject">
            <summary>
            Gets the cell object attached to this cell. Returns null if no object is attached.
            </summary>
            <type link = "http://docs.unity3d.com/ScriptReference/GameObject.html">GameObject</type>
        </member>
        <member name="P:DynamicLoadingKit.IAttachableWorldCell.CellObjectPosition">
            <summary>
            Gets the position that the cell object should be placed at. You can position the object manually, or 
            let it be automatically positioned via AttachCellObjectToCell (by passing in false for 
            objectPositionedCorrectlyAlready).
            </summary>
            <type>bool</type>
        </member>
        <member name="M:DynamicLoadingKit.IAttachableWorldCell.AttachCellObjectToCell(UnityEngine.GameObject,System.Boolean)">
            <summary>
            Attaches a GameObject to the cell. If creating a custom Cell Object Loader or Primary Cell Object 
            Sub Controller class, you should either let the WorldCell position the cell object correctly by 
            passing in false for objectPositionedCorrectlyAlready, or position the object manually (or instantiate it 
            at the correct position) and pass in true.
            </summary>
            <param name="obj" type = "GameObject" link = "http://docs.unity3d.com/ScriptReference/GameObject.html">
            The object to attach to the cell.
            </param>
            <param name="objectPositionedCorrectlyAlready" type="bool">
            If false, the object will be moved to its correct position. If you've already positioned the object at the correct 
            location (CellObjectPosition), you must pass in true.
            </param>
            <displayName id = "AttachCellObjectToCell">AttachCellObjectToCell(GameObject, bool)</displayName>
            <syntax>void AttachCellObjectToCell(GameObject obj, bool objectPositionedCorrectlyAlready)</syntax>
        </member>
        <member name="T:DynamicLoadingKit.IDetachableWorldCell">
            <summary>
            Represents a cell in a <see href = "World.html">World</see> that can have an object "detached" from it.
            </summary>
            <title>IDetachableWorldCell Interface</title>
            <category>Interfaces</category>
            <navigationName>IDetachableWorldCell</navigationName>
            <fileName>IDetachableWorldCell.html</fileName>
            <syntax>public interface IDetachableWorldCell : <see cref="T:DynamicLoadingKit.IWorldCell" href = "IWorldCell.html">IWorldCell</see></syntax>
        </member>
        <member name="M:DynamicLoadingKit.IDetachableWorldCell.DetachCellObjectFromCell">
            <summary>
            Detaches and returns the GameObject attached to the cell.
            </summary>
            <displayName id = "DetachCellObjectFromCell">DetachCellObjectFromCell()</displayName>
            <syntax>GameObject DetachCellObjectFromCell()</syntax>
            <returns type = "GameObject" link = "http://docs.unity3d.com/ScriptReference/GameObject.html">The GameObject that was previously attached to the cell.</returns>
        </member>
        <member name="T:DynamicLoadingKit.IIdentifiable">
            <summary>
            Represents an object which can be Identified via an ID.
            </summary>
            <title>IIdentifiable Interface</title>
            <category>Interfaces</category>
            <navigationName>IIdentifiable</navigationName>
            <fileName>IIdentifiable.html</fileName>
            <syntax>public interface IIdentifiable</syntax>
        </member>
        <member name="P:DynamicLoadingKit.IIdentifiable.ID">
            <summary>
            Gets the identification number of the IIdentifiable object.
            </summary>
            <type>int</type>
        </member>
        <member name="T:DynamicLoadingKit.IWorldUser">
            <summary>
            Represents a user that wishes to be notified when certain events occur on a World. You can register this user 
            via <see cref="M:DynamicLoadingKit.World.Register(DynamicLoadingKit.IWorldUser,System.Int32@)" href="World.html#Register">World.Register</see>
            </summary>
            <title>IWorldUser Interface</title>
            <category>Interfaces</category>
            <navigationName>IWorldUser</navigationName>
            <fileName>IWorldUser.html</fileName>
            <syntax>public interface IWorldUser</syntax>
        </member>
        <member name="M:DynamicLoadingKit.IWorldUser.OnWorldDestroyed">
            <summary>
            Called when the World the user is registered to is about to be destroyed.
            </summary>
            <displayName id="OnWorldDestroyed">OnWorldDestroyed()</displayName>
            <syntax> void OnWorldDestroyed()</syntax>
        </member>
        <member name="M:DynamicLoadingKit.IWorldUser.OnWorldShifted(UnityEngine.Vector3,DynamicLoadingKit.Cell,DynamicLoadingKit.Cell)">
            <summary>
            Called when the World the user is registered to is shifted.
            </summary>
            <param name="shiftAmount" type="Vector3">
            The amount of shift.
            </param>
            <param name="newOriginCell" type="Cell" link="Cell.html">
            The new origin cell of the World after the shift.
            </param>
            <param name="endlessGridResetAddition" type="Cell" link="Cell.html">
            When the world shifts, it resets the endless grid indexes 
            as well. This ensures the endless grid values cannot exceed the maximum integer value (unlikely but possible). 
            This paramater tracks that reset. Basically, if you have a list of endless grid cells you are keeping track of, 
            you should add this value to each of those cells so they are in sync with the World.
            </param>
            <displayName id="OnWorldShifted">OnWorldShifted(Vector3, Cell, Cell)</displayName>
            <syntax>void OnWorldShifted(Vector3 shiftAmount, Cell newOriginCell, Cell endlessGridResetAddition)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.IWorldUser.OnOriginCellChanged(DynamicLoadingKit.Cell)">
            <summary>
            Called when the World the user is registered to has its origin cell changed.
            </summary>
            <param name="newOriginCell" type="Cell" link="Cell.html">The new origin cell of the World.</param>
            <displayName id="">
            OnOriginCellChanged(Cell)
            </displayName>
            <syntax>void OnOriginCellChanged(Cell newOriginCell)</syntax>
        </member>
        <member name="T:DynamicLoadingKit.INamingConvention">
            <summary>
            Represents a Naming Convention
            </summary>
            <title>INamingConvention Interface</title>
            <category>Interfaces</category>
            <navigationName>INamingConvention</navigationName>
            <fileName>INamingConvention.html</fileName>
            <syntax>public interface INamingConvention</syntax>
        </member>
        <member name="P:DynamicLoadingKit.INamingConvention.Format">
            <summary>
            Gets the format of the naming convention. This describes the format of the text following the 
            group name of the terrain or object (the group name is the name common to all objects/terrain in the same group).
            </summary>
            <type>string</type>
        </member>
        <member name="P:DynamicLoadingKit.INamingConvention.NumberingStartsAt0">
            <summary>
            Gets a value indicating whether the naming convention calls for row/column/layer numbers to start at 0.
            If false, the numbers will start at 1 instead.
            </summary>
            <type>bool</type>
        </member>
        <member name="T:DynamicLoadingKit.ICellObjectGroup">
            <summary>
            Represents a Cell Object Group
            </summary>
            <title>ICellObjectGroup Interface</title>
            <category>Interfaces</category>
            <navigationName>ICellObjectGroup</navigationName>
            <fileName>ICellObjectGroup.html</fileName>
            <syntax>public interface ICellObjectGroup</syntax>
        </member>
        <member name="P:DynamicLoadingKit.ICellObjectGroup.GroupName">
            <summary>
            Gets the group name associated with the cell object group.
            </summary>
            <type>string</type>
        </member>
        <member name="P:DynamicLoadingKit.ICellObjectGroup.NamingConvention">
            <summary>
            Gets the Naming Convention associated with the cell object group.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DynamicLoadingKit.ICellObjectGroup.World">
            <summary>
            Gets the World associated with the cell object group.
            </summary>
            <type link = "World.html">World</type>
        </member>
        <member name="T:DynamicLoadingKit.PrimaryCellObjectSubController">
            <summary>
            Provides a base implementation for Primary Cell Object Sub Controllers. These sub controllers are the main components responsible for 
            retrieving cell objects when the 
            <see cref="T:DynamicLoadingKit.World" href="World.html">World</see> needs them, and handling deactivated cell objects when the World is done with them.
            <para>For instance, one sub controller might pool objects when they're not in use, while another might simply destroy them.</para>
            <para>The actual method of loading new objects into the scene is left up to the 
            <see cref="P:DynamicLoadingKit.PrimaryCellObjectSubController.CellObjectLoader" href="CellObjectLoader.html">Cell Object Loader</see> you are using.</para>
            <para>Additional Note: This component contains its own special class (PrimaryCellObjectSubControllerUser) which enables multiple 
            users to use the sub controller at the same time. The data associated with each user is stored in this user object and retrieved
            using the primaryCellObjectSubControllerID passed into each method.</para>
            <para>This user object does not contain any data by default, though if creating your own custom sub controller, 
            you can and should create your own user object class that derives from 
            PrimaryCellObjectSubControllerUser, and use it to store data specific to your custom classes users. You can access the user object via the  
            <see cref="P:DynamicLoadingKit.PrimaryCellObjectSubController.RegisteredUsers" href = "#RegisteredUsers">RegisteredUsers</see> property and primaryCellObjectSubControllerID, like so: RegisteredUsers[primaryCellObjectSubControllerID].</para>
            <para>You should never have to interact directly with this component, as the methods/properties are called/used
            as needed by the Dynamic Loading Kit.</para>
            </summary>
            <title>PrimaryCellObjectSubController Abstract Class</title>
            <category>Sub Controllers</category>
            <navigationName>PrimaryCellObjectSubController</navigationName>
            <fileName>PrimaryCellObjectSubController.html</fileName>
            <syntax>public abstract class PrimaryCellObjectSubController : MonoBehaviour</syntax>
            
            <inspector name="Cell Object Destroyer" type="CellObjectDestroyer" link="CellObjectDestroyer.html">
            An optional Cell Object Destroyer that will be used by the sub controller to destroy objects when they need to be unloaded from 
            the scene. If no destroyer is provided, the root game object will be destroyed (along with its children) in a single frame. Depending on 
            the number of children the root object has, this operation may not be very performant (in which case, use a Cell Object Destroyer).</inspector>
            
            <inspector name="Cell Object Loader" type="CellObjectLoader" link="CellObjectLoader.html">
            The Cell Object Loader that will be used by the sub controller to load new objects into the scene.</inspector>
            
            <inspector name="Memory Freeing Strategy" type="MemoryFreeingStrategy" link="MemoryFreeingStrategy.html">
            Determines the memory freeing strategy to use after one or more game objects have been destroyed by the 
            Primary Cell Object Sub Controller. There may be a performance penalty when utilizing one of the 
            automatic stategies, so you may wish to set this to Manual and call the memory freeing methods 
            (Resources.UnloadUnusedAssets and System.GC.Collect) yourself at a time of your choosing.
            <para>
            Also note that Resources.UnloadUnusedAssets will usually free more memory than GC.Collect 
            (this method may actually be useless for your game, you will have to test this out yourself).
            </para>
            </inspector>
            <inspector name="Post Destroy Yield Time" type="float">When destroying objects, the sub controller will 
            need to destroy a list of root objects rather than just a single object. After each root object 
            is destroyed, the program will wait this amount of time (in seconds) before destroying the next 
            object(s). A value of 0 will destroy all root objects in a single frame (when not using a Cell 
            Object Destroyer) and is not recommended.
            </inspector>
            
            <inspector name="Use Cell Actions" type="bool"><see cref="T:DynamicLoadingKit.CellAction" href="CellAction.html">
            Cell Actions</see> can be attached to 
            cell objects in order to perform custom actions at key times. If none of your objects have Cell 
            Actions, however, the GetComponent call to 
            get the Cell Actions will create unnecessary garbage.
            <para>
            Enable this option only if you are using Cell Actions.
            </para>
            </inspector>
        </member>
        <member name="P:DynamicLoadingKit.PrimaryCellObjectSubController.ObjectsHaveCellActions">
            <summary>
            Gets a value indicating whether Cell Actions are present on the objects.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DynamicLoadingKit.PrimaryCellObjectSubController.CellObjectLoader">
            <summary>
            Gets the Cell Object Loader associated with the sub controller.
            </summary>
            <type link="CellObjectLoader.html">CellObjectLoader (protected)</type>
        </member>
        <member name="P:DynamicLoadingKit.PrimaryCellObjectSubController.CellObjectDestroyer">
            <summary>
            Gets the Cell Object Destroyer associated with the sub controller.
            </summary>
            <type link="CellObjectDestroyer.html">CellObjectDestroyer (protected)</type>
        </member>
        <member name="P:DynamicLoadingKit.PrimaryCellObjectSubController.RegisteredUsers">
            <summary>
            Gets the users registered with the sub controller.
            </summary>
            <type link="RegistrationHandler.html">RegistrationHandler&lt;PrimaryCellObjectSubControllerUser&gt; (protected)</type>
        </member>
        <member name="P:DynamicLoadingKit.PrimaryCellObjectSubController.YieldForTime">
            <summary>
            Gets the YieldInstruction that should be used to yield after a root object has been fully destroyed. If 
            Post Destroy Yield Time is 0, this will return null.
            </summary>
            <tyoe>YieldInstruction (protected)</tyoe>
        </member>
        <member name="M:DynamicLoadingKit.PrimaryCellObjectSubController.AwakeExtended">
            <summary>
            Because this base class utilizes Awake, it's imperative that sub classes do not. Instead, you can override this method 
            and it will be called when the base class's Awake method is called by Unity.
            </summary>
            <displayName id="AwakeExtended">AwakeExtended()</displayName>
            <syntax>protected virtual void AwakeExtended()</syntax>
        </member>
        <member name="M:DynamicLoadingKit.PrimaryCellObjectSubController.Register(DynamicLoadingKit.ICellObjectGroup,System.Int32@)">
            <summary>
            A user can call this method to register with the Primary Cell Object Sub Controller. The primaryCellObjectSubControllerID must be stored by the user
            and passed in when calling the methods of the Primary Cell Object Sub Controller.
            </summary>
            <param name="cellObjectGroup" type="ICellObjectGroup" link="ICellObjectGroup.html">The cell object group being registered.</param>
            <param name="primaryCellObjectSubControllerID" type="out int">An ID that is assigned to the user when this method is called. Each user has its
            own PrimaryCellObjectSubControllerUser object created for it.</param>
            <displayName id="Register">Register(ICellObjectGroup, out int)</displayName>
            <syntax>public void Register(ICellObjectGroup cellObjectGroup, out int primaryCellObjectSubControllerID)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.PrimaryCellObjectSubController.DeRegister(System.Int32)">
            <summary>
            A user can call this method to de register with the Primary Cell Object Sub Controller.
            </summary>
            <param name="primaryCellObjectSubControllerID" type="int">The ID of the user to de register.</param>
            <displayName id="DeRegister">DeRegister(int)</displayName>
            <syntax>public void DeRegister(int primaryCellObjectSubControllerID)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.PrimaryCellObjectSubController.CreateNewUser(DynamicLoadingKit.ICellObjectGroup,System.Int32)">
            <summary>
            Method used to create a new user object during user registration. This can be overridden to return
            a custom user object.
            </summary>
            <param name="cellObjectGroup" type="ICellObjectGroup" link="ICellObjectGroup.html">The cell object group being registered.</param>
            <param name="loaderID" type="int">The loaderID assigned to the sub controller when it registered with the Cell Object Loader it is using.</param>
            <returns type="PrimaryCellObjectSubControllerUser">A new user object created using the worldAssociatedWithUser and loaderID as input.</returns>
            <displayName id="CreateNewUser">CreateNewUser(ICellObjectGroup, int)</displayName>
            <syntax>protected virtual PrimaryCellObjectSubControllerUser CreateNewUser(ICellObjectGroup cellObjectGroup, int loaderID)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.PrimaryCellObjectSubController.AttachCellObjectsToCellsInSingleFrame``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            When overridden in a derived class, attaches the objects associated with the input cells to the cells in a single frame.
            <para>Note that T must implement the <see cref="T:DynamicLoadingKit.IAttachableWorldCell" href = "IAttachableWorldCell.html">IAttachableWorldCell</see> interface.</para>
            </summary>
            <typeparam name="T">The type of the cells.</typeparam>
            <param name="cells" type = "List&lt;T&gt;">The cells whose objects need to be attached.</param>
            <param name="primaryCellObjectSubControllerID" type="int">The ID of the user requesting the attachment.</param>
            <displayName id="AttachCellObjectsToCellsInSingleFrame">AttachCellObjectsToCellsInSingleFrame&lt;T&gt;(List&lt;T&gt;, int)</displayName>
            <syntax>public abstract void AttachCellObjectsToCellsInSingleFrame&lt;T&gt;(List&lt;T&gt; cells, int primaryCellObjectSubControllerID) where T : IAttachableWorldCell</syntax>
        </member>
        <member name="M:DynamicLoadingKit.PrimaryCellObjectSubController.AttachCellObjectsToCells``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            When overridden in a derived class, attaches the objects associated with the input cells to the cells over a period of frames.
            </summary>
            <typeparam name="T">The type of the cells.</typeparam>
            <param name="cells" type = "List&lt;T&gt;">The cells whose objects need to be attached.</param>
            <param name="primaryCellObjectSubControllerID" type = "int">The ID of the user requesting the attachment.</param>
            <displayName id = "AttachCellObjectsToCells">AttachCellObjectsToCells&lt;T&gt;(List&lt;T&gt;, int)</displayName>
            <syntax>public abstract IEnumerator&lt;YieldInstruction&gt; AttachCellObjectsToCells&lt;T&gt;(List&lt;T&gt; cells, int primaryCellObjectSubControllerID) where T : IAttachableWorldCell</syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.</returns>
        </member>
        <member name="M:DynamicLoadingKit.PrimaryCellObjectSubController.DetachAndProcessCellObjectsFromDeactivatedCells``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            When overridden in a derived class, detaches and processes the objects associated with the input cells over a period of frames.
            <para>Processing may include storing the objects in a pool or destroying them.</para>
            </summary>
            <typeparam name="T">The type of the cells.</typeparam>
            <param name="deactivatedCells" type = "List&lt;T&gt;">The cells whose objects need to be detached and processed.</param>
            <param name="primaryCellObjectSubControllerID" type = "int">The ID of the user requesting the detachment and processing.</param>
            <displayName id = "DetachAndProcessCellObjectsFromDeactivatedCells">DetachAndProcessCellObjectsFromDeactivatedCells&lt;T&gt;(List&lt;T&gt;, int)</displayName>
            <syntax>public abstract IEnumerator&lt;YieldInstruction&gt; DetachAndProcessCellObjectsFromDeactivatedCells&lt;T&gt;(List&lt;T&gt; cells, int primaryCellObjectSubControllerID) where T : IAttachableWorldCell</syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.</returns>
        </member>
        <member name="T:DynamicLoadingKit.CellObjectLoader">
            <summary>
            Provides a base implementation for Cell Object Loaders. Cell Object Loaders must be able
            to load objects over several frames or in a single frame. When single frame loading is impossible
            (as is the case with some load methods) pre-loading will be used (pre-loading occurs in one frame, then
            the actual single frame load occurs in the next).
            <para>In order to accomplish this, the 
            <see href = "#IsSingleFrameAttachmentPreloadRequired">IsSingleFrameAttachmentPreloadRequired</see> property must be
            overridden in the derived class to indicate whether pre-loading is required.</para>
            <para>Additional Note: This component contains its own special class (CellObjectLoaderUser) which enables multiple 
            users to use the cell object loader at the same time. The data associated with each user is stored in this user object and retrieved
            using the loaderID passed into each method.</para>
            <para>This user object contains a <see cref="T:DynamicLoadingKit.CellString" href = "CellString.html">Cell String</see>, which you are
            free to use in your own derived cell object loader component. You can access the user object and cell string via the  
            <see cref="P:DynamicLoadingKit.CellObjectLoader.RegisteredUsers" href = "#RegisteredUsers">RegisteredUsers</see> property and loaderID, like so: RegisteredUsers[loaderID] (accesses the user object) or RegisteredUsers[loaderID].CellString.</para>
            <para>You may also create your own custom user object class which
            derives from CellObjectLoaderUser. In fact, this strategy is utilized by some of the other Cell Object Loaders in the kit. Simply override the
            <see cref="M:DynamicLoadingKit.CellObjectLoader.CreateNewUser(DynamicLoadingKit.ICellObjectGroup)" href = "#CreateNewUser">CreateNewUser</see> method and return your custom user object.</para>
            <para>You should never have to interact directly with this component, as the methods/properties are called/used
            as needed by the Dynamic Loading Kit.</para>
            </summary>
            <title>CellObjectLoader Abstract Class</title>
            <category>Cell Object Loaders</category>
            <navigationName>CellObjectLoader</navigationName>
            <fileName>CellObjectLoader.html</fileName>
            <syntax>public abstract class CellObjectLoader : MonoBehaviour</syntax>
        </member>
        <member name="P:DynamicLoadingKit.CellObjectLoader.IsSingleFrameAttachmentPreloadRequired">
            <summary>
            When overridden in derived class, gets a bool value indicating whether the derived class
            requires pre loading in order to perform a single frame attachment.
            <para>If overridden to return true, then the 
            <see cref="M:DynamicLoadingKit.CellObjectLoader.PerformSingleFrameAttachmentPreload``1(System.Collections.Generic.List{``0},System.Int32)" href = "#PerformSingleFrameAttachmentPreload">PerformSingleFrameAttachmentPreload</see> method must also be overridden.</para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DynamicLoadingKit.CellObjectLoader.RegisteredUsers">
            <summary>
            The users registered with the Cell Object Loader.
            </summary>
            <type link = "RegistrationHandler.html">RegistrationHandler&lt;CellObjectLoaderUser&gt; (protected)</type>
        </member>
        <member name="M:DynamicLoadingKit.CellObjectLoader.Register(DynamicLoadingKit.ICellObjectGroup,System.Int32@)">
            <summary>
            A user can call this method to register with the Cell Object Loader. The loaderID must be stored by the user
            and passed in when calling the methods of the Cell Object Loader.
            </summary>
            <param name="cellObjectGroup" type="ICellObjectGroup" link="ICellObjectGroup.html">
            The cell object group being registered.
            </param>
            <param name="loaderID" type = "int">
            An ID that is assigned to the user when this method is called. Each user has its
            own CellObjectLoaderUser object created for it.
            </param>
            <displayName id = "Register">Register(ICellObjectGroup, out int)</displayName>
            <syntax>public void Register(ICellObjectGroup cellObjectGroup, out int loaderID)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.CellObjectLoader.DeRegister(System.Int32)">
            <summary>
            A user can call this method to de register with the Cell Object Loader.
            </summary>
            <param name="loaderID" type = "int">The ID of the user to de register.</param>
            <displayName id = "DeRegister">DeRegister(int)</displayName>
            <syntax>public void DeRegister(int loaderID)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.CellObjectLoader.CreateNewUser(DynamicLoadingKit.ICellObjectGroup)">
            <summary>
            Method used to create a new user object during user registration. This can be overridden to return
            a custom user object.
            </summary>
            <param name="cellObjectGroup" type="ICellObjectGroup" link="ICellObjectGroup.html">The cell object group being registered.</param>
            <displayName id = "CreateNewUser">CreateNewUser(ICellObjectGroup)</displayName>
            <syntax>protected virtual CellObjectLoaderUser CreateNewUser(ICellObjectGroup cellObjectGroup)</syntax>
            <returns type = "CellObjectLoaderUser">A new user object created using the worldAssociatedWithUser as input.</returns>
        </member>
        <member name="M:DynamicLoadingKit.CellObjectLoader.PerformSingleFrameAttachmentPreload``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Certain types of load methods require a frame to pass before objects are added to the scene (LoadLevelAdditive for example). In order to 
            properly utilize the AttachCellObjectsToCellsInSingleFrame method, these load methods must "pre load" the objects in the frame before. 
            This method is used to do that, but should only be called by the registered user when IsSingleFrameAttachmentPreloadRequired is true.
            <para>By default, this method does nothing, and you only need to provide your own implementation if pre loading is required (in 
            which case, <see cref="P:DynamicLoadingKit.CellObjectLoader.IsSingleFrameAttachmentPreloadRequired" href = "#IsSingleFrameAttachmentPreloadRequired">IsSingleFrameAttachmentPreloadRequired</see> 
            must also be overridden to return true.</para>
            </summary>
            <typeparam name="T">The type of the cells.</typeparam>
            <param name="cells" type = "List&lt;T&gt;">The cells whose objects need to be pre loaded.</param>
            <param name="loaderID" type = "int">The ID of the user requesting the pre load.</param>
            <displayName id = "PerformSingleFrameAttachmentPreload">PerformSingleFrameAttachmentPreload&lt;T&gt;(List&lt;T&gt;, int)</displayName>
            <syntax>public virtual void PerformSingleFrameAttachmentPreload&lt;T&gt;(List&lt;T&gt; cells, int loaderID) where T : IAttachableWorldCell</syntax>
        </member>
        <member name="M:DynamicLoadingKit.CellObjectLoader.AttachCellObjectsToCellsInSingleFrame``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            When overridden in a derived class, attaches the objects associated with the input cells to the cells in a single frame.
            <para>Note that T must implement the <see cref="T:DynamicLoadingKit.IAttachableWorldCell" href = "IAttachableWorldCell.html">IAttachableWorldCell</see> interface.</para>
            </summary>
            <typeparam name="T">The type of the cells.</typeparam>
            <param name="cells" type = "List&lt;T&gt;">The cells whose objects need to be attachment.</param>
            <param name="loaderID" type = "int">The ID of the user requesting the attachment.</param>
            <displayName id = "AttachCellObjectsToCellsInSingleFrame">AttachCellObjectsToCellsInSingleFrame&lt;T&gt;(List&lt;T&gt;, int)</displayName>
            <syntax>public abstract void AttachCellObjectsToCellsInSingleFrame&lt;T&gt;(List&lt;T&gt; cells, int loaderID) where T : IAttachableWorldCell</syntax>
        </member>
        <member name="M:DynamicLoadingKit.CellObjectLoader.LoadAndAttachCellObjectsToCells``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            When overridden in a derived class, loads and attaches the objects associated with the input cells to the cells over a period of frames.
            </summary>
            <typeparam name="T">The type of the cells.</typeparam>
            <param name="cells" type = "List&lt;T&gt;">The cells whose objects need to be loaded and attached.</param>
            <param name="loaderID" type = "int">The ID of the user requesting the load and attachment.</param>
            <displayName id = "LoadAndAttachCellObjectsToCells">LoadAndAttachCellObjectsToCells&lt;T&gt;(List&lt;T&gt;, int)</displayName>
            <syntax>public abstract IEnumerator&lt;YieldInstruction&gt; LoadAndAttachCellObjectsToCells&lt;T&gt;(List&lt;T&gt; cells, int loaderID) where T : IAttachableWorldCell</syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.</returns>
        </member>
        <member name="T:DynamicLoadingKit.PlayerPrefsPersistentDataController">
            <summary>
            Provides an implementation for a Persistent Data Controller that uses Unity's built in <see href="http://docs.unity3d.com/ScriptReference/PlayerPrefs.html">Player Prefs</see> to save and load
            persistent data between game sessions.
            </summary>
            <title>PlayerPrefsPersistentDataController Class</title>
            <category>Primary Components</category>
            <navigationName>PlayerPrefsPersistentDataController</navigationName>
            <fileName>PlayerPrefsPersistentDataController.html</fileName>
            <syntax>public class PlayerPrefsPersistentDataController : <see href = "PersistentDataController.html">PersistentDataController</see></syntax>
        </member>
        <member name="M:DynamicLoadingKit.PlayerPrefsPersistentDataController.SaveData(System.String,System.String)">
            <summary>
            Saves the specified data using the specified key in Player Prefs.
            </summary>
            <param name="key" type="string">The key used to save the persistent data.</param>
            <param name="data" type="string">The persistent data that will be saved.</param>
            <displayName id="SaveData">SaveData(string, string)</displayName>
            <syntax>public sealed override void SaveData(string key, string data)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.PlayerPrefsPersistentDataController.TryGetData(System.String,System.String@)">
            <summary>
            Attempts to get the persistent data associated with the specified key from Player Prefs.
            </summary>
            <param name="key" type="string">The key used to try and retrieve the persistent data.</param>
            <param name="data" type="out string">A string which will contain the data if successfully retrieved.</param>
            <returns type="bool">A value indicating whether the data was successfully retrieved. If false, "data" will be null.</returns>
            <displayName id="TryGetData">TryGetData(string, out string)</displayName>
            <syntax>public sealed override bool TryGetData(string key, out string data)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.PlayerPrefsPersistentDataController.TryDeleteData(System.String)">
            <summary>
            Attempts to to delete the persistent data associated with the specified key from Player Prefs.
            </summary>
            <param name="key" type="string">The key used to identify the persistent data that should be deleted.</param>
            <returns type ="bool">A value indicating whether the persistent data was successfully deleted.</returns>
            <displayName id="TryDeleteData">TryDeleteData(string)</displayName>
            <syntax>public sealed override bool TryDeleteData(string key)</syntax>
        </member>
        <member name="T:DynamicLoadingKit.BoundaryMonitor">
            <summary>
            A component which actively monitors boundaries.
            <para>This component is not meant to be used outside of the Dynamic Loading Kit, and as such
            many of its members are hidden. Look at the source code provided with the kit if you wish to create
            your own boundary monitor based on this one for non DLK stuff.
            </para>
            <para>
            Each Boundary Monitor user can supply a dynamic and static boundary to monitor.
            </para>
            </summary>
            <title>BoundaryMonitor Class</title>
            <category>Secondary Components</category>
            <navigationName>BoundaryMonitor</navigationName>
            <fileName>BoundaryMonitor.html</fileName>
            <syntax>public class BoundaryMonitor : MonoBehaviour</syntax>
            <inspector name = "Detection Frequency" type = "float">The frequency at which the player's position
            will be checked to see if they've crossed a boundary.</inspector>
        </member>
        <member name="M:DynamicLoadingKit.BoundaryMonitor.UpdateDetectionFrequency(System.Single)">
            <summary>
            Updates the frequency at which this Boundary Monitor checks to see if
            the player has crossed a boundary.
            </summary>
            <displayName id = "UpdateDetectionFrequency">UpdateDetectionFrequency(float)</displayName>
            <syntax>public void UpdateDetectionFrequency(float newDetectionFrequency)</syntax>
            <param name="newDetectionFrequency" type = "float">The new frequency, in seconds.</param>
        </member>
        <member name="T:DynamicLoadingKit.WorldGridBase">
            <summary>
            Provides a base implementation for World Grid's. The World Grid provided 
            in the DLK is simply an empty shell which derives from
            WorldGridBase, so you can effectively treat the WorldGrid and WorldGridBase like they are one in the same.
            <para>
            Each World Grid represents a group of objects. It stores vital information about these objects and serves as a blueprint
            for building <see cref="T:DynamicLoadingKit.World" href="World.html">World's</see> at runtime.
            </para>
            <para>
            Remember to hover over option names with a * to see more information about that option. 
            Ensure all the options are set correctly,
            and then press the "Set Data" button. The data MUST be set in order for the DLk to function properly.
            </para>
            <para>
            Also note, Initialize should be called prior to any other methods/properties being called/accessed.
            </para>
            <para>
            To create a World Grid asset, right click the folder where you'd like to create it and choose 
            "Dynamic Loading Kit -> Create World Grid".
            </para>
            <para>
            Finally, note that all of the public methods that take in or return a <see cref="T:DynamicLoadingKit.Cell" href="Cell.html">Cell</see> 
            are 0 based. This means the first 
            cell on the world grid or endless world grid is 0, 0, 0 rather than 1, 1, 1.
            </para>
            </summary>
            <title>WorldGridBase Abstract Class</title>
            <category>Other Classes</category>
            <navigationName>WorldGridBase</navigationName>
            <fileName>WorldGridBase.html</fileName>
            <syntax>public abstract class WorldGridBase : <see href="http://docs.unity3d.com/ScriptReference/ScriptableObject.html">ScriptableObject</see></syntax>
            
            <inspector name = "Cell Object Type" type="CellObjectType" link="CellObjectType.html">The type of the objects associated with this World Grid.</inspector>
            
            <inspector name="Columns" type="int">The number of columns in the object group associated with this World Grid.</inspector>
            
            <inspector name="Default Column Width" type="float">The default column width to use when setting the World Grid's data.
            <para>This is displayed and used only when "Method to Set Data" is set to "Set Using Default Values", or when the method is "Set Using Prefabs" and no
            data can be found for a particular column.</para></inspector>
            
            <inspector name="Default Layer Height" type="float">The default layer height to use when setting the World Grid's data.
            <para>This is displayed and used for Three Dimensional World Types, only when "Method to Set Data" is set to "Set Using Default Values", or when the method is "Set Using Prefabs" and no
            data can be found for a particular layer.</para></inspector>
            
            <inspector name="Default Row Length" type="float">The default row length to use when setting the World Grid's data.
            <para>This is displayed and used only when "Method to Set Data" is set to "Set Using Default Values", or when the method is "Set Using Prefabs" and no
            data can be found for a particular row.</para></inspector>
            
            <inspector name = "Default Group Name" type = "string">The group name of the cell objects associated with this World Grid. For instance, if your objects are 
            named "Slice_1_1," "Slice_1_2_," "Slice_1_3," etc., the group name would be "Slice".</inspector>
            
            <inspector name="Layers" type="int">The number of layers in the object group associated with this World Grid.
            <para>This option is only displayed when the "World Type" is set to "Three Dimensional".</para></inspector>
            
            <inspector name="Method to Set Data" type="string">The method to use to set the World Grid's data.
            <para>There are three options; select and hover over each option in the inspector to see more information about them.</para></inspector>
            
            <inspector name="Naming Convention" type="NamingConvention" link="NamingConvention.html">
            The Naming Convention that describes the objects in this World's group. If no naming convention is provided, the default naming 
            convention of GroupName_Row_Column (or GroupName_Layer_Row_Column) will be used.
            </inspector>
            
            <inspector name="Rows" type="int">The number of rows in the object group associated with this World Grid.</inspector>
            
            <inspector name="Text Asset With Data" type="TextAsset" link="http://docs.unity3d.com/ScriptReference/TextAsset.html">
            The TextAsset that should be used to set this World Grid's data.<para>Only displayed when "Method to Set Data" is set to
            "Set Using Text Asset".</para></inspector>
            
            <inspector name="World Type" type="WorldType" link="WorldType.html">The type of world formed by the objects associated with this World Grid.</inspector>
            
            <inspector name="X Cell Offset %" type="float">The amount your objects will be offset on the X axis in relation to the total width of your cells.
            <para>This option is only displayed and used after you set your Grid's data, and only if your "Cell Object Type" is not "Unity Terrains".
            </para><para>This is mainly useful for centering objects which are smaller than the cells they are contained within. 
            If your objects and cells dimensions along the X axis are the same, you do not need to worry about setting this value</para></inspector>
            
            <inspector name="Y Cell Offset %" type="float">The amount your objects will be offset on the Y axis in relation to the total length/height of your cells.
            <para>This option is only displayed and used after you set your Grid's data, and only if your "Cell Object Type" is not "Unity Terrains".
            </para><para>This is mainly useful for centering objects which are smaller than the cells they are contained within. 
            If your objects and cells dimensions along the Y axis are the same, you do not need to worry about setting this value</para></inspector>
            
            <inspector name="Z Cell Offset %" type="float">The amount your objects will be offset on the Z axis in relation to the total length of your cells.
            <para>This option is only displayed and used after you set your Grid's data, and only if your "Cell Object Type" is not "Unity Terrains".
            </para><para>This is mainly useful for centering objects which are smaller than the cells they are contained within. 
            If your objects and cells dimensions along the Z axis are the same, you do not need to worry about setting this value</para></inspector>
        </member>
        <member name="M:DynamicLoadingKit.WorldGridBase.Initialize">
            <summary>
            Initializes the World Grid. Must be called once before other methods can be called.
            </summary>
            <displayName id="Initialize">Initialize()</displayName>
            <syntax>public void Initialize()</syntax>
            <exception name="WorldGridNotSetException" link="WorldGridNotSetException.html">Thrown when the World Grid's data has not been set prior (in the inspector)
            to this method being called.</exception>
        </member>
        <member name="P:DynamicLoadingKit.WorldGridBase.CellObjectType">
            <summary>
            Gets the Cell Object Type of the objects associated with the World Grid.
            </summary>
            <type link="CellObjectType.html">CellObjectType</type>
        </member>
        <member name="P:DynamicLoadingKit.WorldGridBase.Columns">
            <summary>
            Gets the number of columns on the World Grid.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DynamicLoadingKit.WorldGridBase.DataSet">
            <summary>
            Gets a value indicating whether the World Grid's data has been set (in the inspector).
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DynamicLoadingKit.WorldGridBase.GroupName">
            <summary>
            Gets the default group name of this World Grid. This is the name assigned in the inspector. 
            If you wish to load alternate versions of your objects, you can change the World's Group name via the 
            <see cref="M:DynamicLoadingKit.World.ChangeGroupName(System.String,System.Boolean)" href="World.html#ChangeGroupName">ChangeGroupName</see> method.
            </summary>
            <type>string</type>
        </member>
        <member name="P:DynamicLoadingKit.WorldGridBase.Height">
            <summary>
            Gets the height of the World Grid, which is the distance between the beginning of the first layer and end of the last layer.
            <para>Will always be 0 if the World Type is not Three Dimensional</para>
            </summary>
            <type>float</type>
        </member>
        <member name="P:DynamicLoadingKit.WorldGridBase.IsInitialized">
            <summary>
            Gets a value indicating if the World Grid is initialized.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DynamicLoadingKit.WorldGridBase.Layers">
            <summary>
            Gets the number of layers on the World Grid. Will be 1 if the World Type is not Three Dimensional.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DynamicLoadingKit.WorldGridBase.Length">
            <summary>
            Gets the length of the World Grid, which is the distance between the beginning of the first row and end of the last row.
            </summary>
            <type>float</type>
        </member>
        <member name="P:DynamicLoadingKit.WorldGridBase.PositionOffset">
            <summary>
            Gets the x, y, and z position offsets of the World Grid.
            </summary>
            <type>Vector3</type>
        </member>
        <member name="P:DynamicLoadingKit.WorldGridBase.Rows">
            <summary>
            Gets the number of rows on the World Grid.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DynamicLoadingKit.WorldGridBase.Width">
            <summary>
            Gets the width of the World Grid, which is the distance between the beginning of the first column and end of the last column.
            </summary>
            <type>float</type>
        </member>
        <member name="P:DynamicLoadingKit.WorldGridBase.WorldType">
            <summary>
            Gets the World Type of the World Grid.
            </summary>
            <type link="WorldType.html">WorldType</type>
        </member>
        <member name="M:DynamicLoadingKit.WorldGridBase.GetIsWorldGridCellEmptyFunction">
            <summary>
            Gets a Function that can be used to check if a given world grid cell is empty. It will be empty if an object
            is not associated with that cell.
            <para>This is a runtime method and should not be used in the editor.</para>
            </summary>
            <returns type="Func&lt;Cell, bool&gt;">
            A function that can be used to determine if a cell on the world grid is empty (has an object associated with it.
            </returns>
            <displayName id="GetIsWorldGridCellEmptyFunction">GetIsWorldGridCellEmptyFunction()</displayName>
            <syntax>public Func&lt;Cell, bool&gt; GetIsWorldGridCellEmptyFunction()</syntax>
        </member>
        <member name="M:DynamicLoadingKit.WorldGridBase.GetLengthOfWorldGridRow(System.Int32)">
            <summary>
            Get the length of a world grid row. The input worldGridRow should be 0 index based. 
            For instance, to get the length of the very first row
            in the grid, you would pass in 0, not 1. To get the second row, you'd pass in 1, not 2, and so on.
            <para>This is a runtime method and should not be used in the editor.</para>
            </summary>
            <param name="worldGridRow" type="float">The row who's length should be retrieved.</param>
            <displayName id="GetLengthOfWorldGridRow">GetLengthOfWorldGridRow(int)</displayName>
            <syntax>public float GetLengthOfWorldGridRow(int worldGridRow)</syntax>
            <returns type="float">The length of the input worldGridRow.</returns>
        </member>
        <member name="M:DynamicLoadingKit.WorldGridBase.GetLengthOfEndlessGridRow(System.Int32)">
            <summary>
            Get the length of an endless grid row. Each input endless grid row is translated
            to its equivalent world grid row, and then the length of that world grid row is returned.
            <para>This is a runtime method and should not be used in the editor.</para>
            </summary>
            <param name="endlessGridRow" type="float">The row who's length should be retrieved.</param>
            <displayName id="GetLengthOfEndlessGridRow">GetLengthOfEndlessGridRow(int)</displayName>
            <syntax>public float GetLengthOfEndlessGridRow(int endlessGridRow)</syntax>
            <returns type="float">The length of the input endlessGridRow.</returns>
        </member>
        <member name="M:DynamicLoadingKit.WorldGridBase.GetPositionOfEndlessGridRow(System.Int32,System.Int32,System.Single)">
            <summary>
            Gets the position of a row on a theoretically endless grid. Note that the World Grid knows nothing about 
            positioning in World Space, so for this method to work you you must pass in the current origin cell row of your world and 
            the position of that origin cell row. If using this with a World component, the origin cell row can be queried 
            via the World's OriginCell property, while the position can be queried via the OriginRowPosition property.
            <para>This is a runtime method and should not be used in the editor.</para>
            </summary>
            <param name="endlessGridRow" type="int">The row whose position you wish to get.</param>
            <param name="originCellRow" type="int">The origin cell row of your World.</param>
            <param name="originCellRowPosition" type="float">The origin cell row position of your World.</param>
            <displayName id="GetPositionOfEndlessGridRow">GetPositionOfEndlessGridRow(int, int, float)</displayName>
            <syntax>public float GetPositionOfEndlessGridRow(int endlessGridRow, int originCellRow, float originCellRowPosition)</syntax>
            <returns type="flaot">The position of the endless grid row.</returns>
        </member>
        <member name="M:DynamicLoadingKit.WorldGridBase.FindEndlessGridRowPointIsIn(System.Single,System.Int32,System.Single)">
            <summary>
            Finds the endless grid row that a point in world space falls within.
            <para>This is a runtime method and should not be used in the editor.</para>
            </summary>
            <param name="point" type="float">The point that will be used to find the endless grid row.</param>
            <param name="originCellRow" type="int">The origin cell row of your World.</param>
            <param name="originCellRowPosition" type="float">The origin cell row position of your World.</param>
            <displayName id="FindEndlessGridRowPointIsIn1">FindEndlessGridRowPointIsIn(float, int, float)</displayName>
            <syntax>public int FindEndlessGridRowPointIsIn(float point, int originCellRow, float originCellRowPosition)</syntax>
            <returns type="int">The endless grid row that the point is in.</returns>
        </member>
        <member name="M:DynamicLoadingKit.WorldGridBase.FindEndlessGridRowPointIsIn(System.Single,System.Int32,System.Single,System.Single@)">
            <summary>
            Finds the endless grid row that a point in world space falls within.
            <para>This is a runtime method and should not be used in the editor.</para>
            </summary>
            <param name="point" type="float">The point that will be used to find the endless grid row.</param>
            <param name="originCellRow" type="int">The origin cell row of your World.</param>
            <param name="originCellRowPosition" type="float">The origin cell row position of your World.</param>
            <param name="rowDisplacementFromOrigin" type="out float">An additional out parameter that meausres the displacement of the 
            found endless grid row to the origin cell's row.</param>
            <displayName id="FindEndlessGridRowPointIsIn2">FindEndlessGridRowPointIsIn(float, int, float, out float)</displayName>
            <syntax>public int FindEndlessGridRowPointIsIn(float point, int originCellRow, float originCellRowPosition, out float rowDistanceFromOrigin)</syntax>
            <returns type="int">The endless grid row that the point is in.</returns>
        </member>
        <member name="M:DynamicLoadingKit.WorldGridBase.ConvertEndlessGridRowToWorldGridRow(System.Int32)">
            <summary>
            Converts an endless grid row to a row on the World Grid.
            </summary>
            <param name="endlessGridRow" type="int">The endless grid row to convert.</param>
            <displayName id="ConvertEndlessGridRowToWorldGridRow">ConvertEndlessGridRowToWorldGridRow(int)</displayName>
            <syntax>public int ConvertEndlessGridRowToWorldGridRow(int endlessGridRow)</syntax>
            <returns type="int">The row on the World Grid</returns>
        </member>
        <member name="M:DynamicLoadingKit.WorldGridBase.GetWidthOfWorldGridColumn(System.Int32)">
            <summary>
            Get the width of a world grid column. The input worldGridColumn should be 0 index based. 
            For instance, to get the width of the very first column
            in the grid, you would pass in 0, not 1. To get the second column, you'd pass in 1, not 2, and so on.
            <para>This is a runtime method and should not be used in the editor.</para>
            </summary>
            <param name="worldGridColumn" type="float">The column who's width should be retrieved.</param>
            <displayName id="GetWidthOfWorldGridColumn">GetWidthOfWorldGridColumn(int)</displayName>
            <syntax>public float GetWidthOfWorldGridColumn(int worldGridColumn)</syntax>
            <returns type="float">The width of the input worldGridColumn.</returns>
        </member>
        <member name="M:DynamicLoadingKit.WorldGridBase.GetWidthOfEndlessGridColumn(System.Int32)">
            <summary>
            Get the width of an endless grid column. Each input endless grid column is translated
            to its equivalent world grid column, and then the width of that world grid column is returned.
            <para>This is a runtime method and should not be used in the editor.</para>
            </summary>
            <param name="endlessGridColumn" type="float">The column who's width should be retrieved.</param>
            <displayName id="GetWidthOfEndlessGridColumn">GetWidthOfEndlessGridColumn(int)</displayName>
            <syntax>public float GetWidthOfEndlessGridColumn(int endlessGridColumn)</syntax>
            <returns type="float">The width of the input endlessGridColumn.</returns>
        </member>
        <member name="M:DynamicLoadingKit.WorldGridBase.GetPositionOfEndlessGridColumn(System.Int32,System.Int32,System.Single)">
            <summary>
            Gets the position of a column on a theoretically endless grid. Note that the World Grid knows nothing about 
            positioning in World Space, so for this method to work you you must pass in the current origin 
            cell column of your world and 
            the position of that origin cell column. If using this with a World component, the origin cell column can be queried 
            via the World's OriginCell property, while the position can be queried via the OriginColumnPosition property.
            <para>This is a runtime method and should not be used in the editor.</para>
            </summary>
            <param name="endlessGridColumn" type="int">The column whose position you wish to get.</param>
            <param name="originCellColumn" type="int">The origin cell column of your World.</param>
            <param name="originCellColumnPosition" type="float">The origin cell column position of your World.</param>
            <displayName id="GetPositionOfEndlessGridColumn">GetPositionOfEndlessGridColumn(int, int, float)</displayName>
            <syntax>public float GetPositionOfEndlessGridColumn(int endlessGridColumn, int originCellColumn, float originCellColumnPosition))</syntax>
            <returns type="flaot">The position of the endless grid column.</returns>
        </member>
        <member name="M:DynamicLoadingKit.WorldGridBase.FindEndlessGridColumnPointIsIn(System.Single,System.Int32,System.Single)">
            <summary>
            Finds the endless grid column that a point in world space falls within.
            <para>This is a runtime method and should not be used in the editor.</para>
            </summary>
            <param name="point" type="float">The point that will be used to find the endless grid column.</param>
            <param name="originCellColumn" type="int">The origin cell column of your World.</param>
            <param name="originCellColumnPosition" type="float">The origin cell column position of your World.</param>
            <displayName id="FindEndlessGridColumnPointIsIn1">FindEndlessGridColumnPointIsIn(float, int, float)</displayName>
            <syntax>public int FindEndlessGridColumnPointIsIn(float point, int originCellColumn, float originCellColumnPosition)</syntax>
            <returns type="int">The endless grid column that the point is in.</returns>
        </member>
        <member name="M:DynamicLoadingKit.WorldGridBase.FindEndlessGridColumnPointIsIn(System.Single,System.Int32,System.Single,System.Single@)">
            <summary>
            Finds the endless grid column that a point in world space falls within.
            <para>This is a runtime method and should not be used in the editor.</para>
            </summary>
            <param name="point" type="float">The point that will be used to find the endless grid column.</param>
            <param name="originCellColumn" type="int">The origin cell column of your World.</param>
            <param name="originCellColumnPosition" type="float">The origin cell column position of your World.</param>
            <param name="columnDisplacementFromOrigin" type="out float">An additional out parameter that meausres the displacement of the 
            found endless grid column to the origin cell's column.</param>
            <displayName id="FindEndlessGridColumnPointIsIn2">FindEndlessGridColumnPointIsIn(float, int, float, out float)</displayName>
            <syntax>public int FindEndlessGridColumnPointIsIn(float point, int originCellColumn, float originCellColumnPosition, out float columnDistanceFromOrigin)</syntax>
            <returns type="int">The endless grid column that the point is in.</returns>
        </member>
        <member name="M:DynamicLoadingKit.WorldGridBase.ConvertEndlessGridColumnToWorldGridColumn(System.Int32)">
            <summary>
            Converts an endless grid column to a column on the World Grid.
            </summary>
            <param name="endlessGridColumn" type="int">The endless grid column to convert.</param>
            <displayName id="ConvertEndlessGridColumnToWorldGridColumn">ConvertEndlessGridColumnToWorldGridColumn(int)</displayName>
            <syntax>public int ConvertEndlessGridColumnToWorldGridColumn(int endlessGridColumn)</syntax>
            <returns type="int">The column on the World Grid</returns>
        </member>
        <member name="M:DynamicLoadingKit.WorldGridBase.GetHeightOfWorldGridLayer(System.Int32)">
            <summary>
            Get the height of a world grid layer. The input worldGridLayer should be 0 index based. For instance, to get the 
            height of the very first layer
            in the grid, you would pass in 0, not 1. To get the second layer, you'd pass in 1, not 2, and so on.
            <para>This is a runtime method and should not be used in the editor.</para>
            </summary>
            <param name="worldGridLayer" type="float">The layer who's height should be retrieved.</param>
            <displayName id="GetHeightOfWorldGridLayer">GetHeightOfWorldGridLayer(int)</displayName>
            <syntax>public float GetHeightOfWorldGridLayer(int worldGridLayer)</syntax>
            <returns type="float">The height of the input worldGridLayer.</returns>
        </member>
        <member name="M:DynamicLoadingKit.WorldGridBase.GetHeightOfEndlessGridLayer(System.Int32)">
            <summary>
            Get the height of an endless grid layer. Each input endless grid layer is translated
            to its equivalent world grid layer, and then the height of that world grid layer is returned.
            <para>This is a runtime method and should not be used in the editor.</para>
            </summary>
            <param name="endlessGridLayer" type="float">The layer who's height should be retrieved.</param>
            <displayName id="GetHeightOfEndlessGridLayer">GetHeightOfEndlessGridLayer(int)</displayName>
            <syntax>public float GetHeightOfEndlessGridLayer(int endlessGridLayer)</syntax>
            <returns type="float">The height of the input endlessGridLayer.</returns>
        </member>
        <member name="M:DynamicLoadingKit.WorldGridBase.GetPositionOfEndlessGridLayer(System.Int32,System.Int32,System.Single)">
            <summary>
            Gets the position of a layer on a theoretically endless grid. Note that the World Grid knows nothing about 
            positioning in World Space, so for this method to work you you must pass in the current origin cell layer of your world and 
            the position of that origin cell layer. If using this with a World component, the origin cell layer can be queried 
            via the World's OriginCell property, while the position can be queried via the OriginLayerPosition property.
            <para>This is a runtime method and should not be used in the editor.</para>
            </summary>
            <param name="endlessGridLayer" type="int">The layer whose position you wish to get.</param>
            <param name="originCellLayer" type="int">The origin cell layer of your World.</param>
            <param name="originCellLayerPosition" type="float">The origin cell layer position of your World.</param>
            <displayName id="GetPositionOfEndlessGridLayer">GetPositionOfEndlessGridLayer(int, int, float)</displayName>
            <syntax>public float GetPositionOfEndlessGridLayer(int endlessGridLayer, int originCellLayer, float originCellLayerPosition)</syntax>
            <returns type="float">The position of the endless grid layer.</returns>
        </member>
        <member name="M:DynamicLoadingKit.WorldGridBase.FindEndlessGridLayerPointIsIn(System.Single,System.Int32,System.Single)">
            <summary>
            Finds the endless grid layer that a point in world space falls within.
            <para>This is a runtime method and should not be used in the editor.</para>
            </summary>
            <param name="point" type="float">The point that will be used to find the endless grid layer.</param>
            <param name="originCellLayer" type="int">The origin cell layer of your World.</param>
            <param name="originCellLayerPosition" type="float">The origin cell layer position of your World.</param>
            <displayName id="FindEndlessGridLayerPointIsIn1">FindEndlessGridLayerPointIsIn(float, int, float)</displayName>
            <syntax>public int FindEndlessGridLayerPointIsIn(float point, int originCellLayer, float originCellLayerPosition)</syntax>
            <returns type="int">The endless grid layer that the point is in.</returns>
        </member>
        <member name="M:DynamicLoadingKit.WorldGridBase.FindEndlessGridLayerPointIsIn(System.Single,System.Int32,System.Single,System.Single@)">
            <summary>
            Finds the endless grid layer that a point in world space falls within.
            </summary>
            <para>This is a runtime method and should not be used in the editor.</para>
            <param name="point" type="float">The point that will be used to find the endless grid layer.</param>
            <param name="originCellLayer" type="int">The origin cell layer of your World.</param>
            <param name="originCellLayerPosition" type="float">The origin cell layer position of your World.</param>
            <param name="layerDisplacementFromOrigin" type="out float">An additional out parameter that meausres the displacement of the 
            found endless grid layer to the origin cell's layer. (Ex: if found cell is above the origin, displacement will be positive, if below it will be negative).</param>
            <displayName id="FindEndlessGridLayerPointIsIn2">FindEndlessGridLayerPointIsIn(float, int, float, out float)</displayName>
            <syntax>public int FindEndlessGridLayerPointIsIn(float point, int originCellLayer, float originCellLayerPosition, out float layerDistanceFromOrigin)</syntax>
            <returns type="int">The endless grid layer that the point is in.</returns>
        </member>
        <member name="M:DynamicLoadingKit.WorldGridBase.ConvertEndlessGridLayerToWorldGridLayer(System.Int32)">
            <summary>
            Converts an endless grid layer to a layer on the World Grid.
            </summary>
            <param name="endlessGridLayer" type="int">The endless grid layer to convert.</param>
            <displayName id="ConvertEndlessGridLayersToWorldGridLayers">ConvertEndlessGridLayersToWorldGridLayers(int)</displayName>
            <syntax>public int ConvertEndlessGridLayersToWorldGridLayers(int endlessGridLayer)</syntax>
            <returns type="int">The layer on the World Grid</returns>
        </member>
        <member name="M:DynamicLoadingKit.WorldGridBase.GetPositionOfEndlessGridCell(DynamicLoadingKit.Cell,DynamicLoadingKit.Cell,UnityEngine.Vector3)">
            <summary>
            Gets the position of an endless grid cell in world space. Because the World Grid knows nothing about
            world space, you must pass in the origin cell and origin cell position of your world for this to work.
            <para>
            It is recommended to use the inidivual get position methods (GetPositionOfEndlessGridColumn, etc.) if you 
            are getting the position frequently, as those methods are slightly more performant.
            </para>
            </summary>
            <param name="endlessGridCell" type="Cell" link="Cell.html">The endless grid cell whose position will be found.</param>
            <param name="originCell" type="Cell" link="Cell.html">The origin cell of your world. Usually will be (1, 1, 1), 
            unless your world is set to stay centered around the origin.</param>
            <param name="originCellPosition" type="Vector3">
            The position of the origin cell of your world. This should simply be the origin of your world.
            </param>
            <displayName id="GetPositionOfEndlessGridCell">
            GetPositionOfEndlessGridCell(Cell, Cell, Vector3)
            </displayName>
            <syntax>
            public Vector3 GetPositionOfEndlessGridCell(Cell endlessGridCell, Cell originCell, Vector3 originCellPosition)
            </syntax>
            <returns type="Vector3">The position of the endless grid cell.</returns>
        </member>
        <member name="T:DynamicLoadingKit.WorldCell">
            <summary>
            Represents a cell on the <see cref="T:DynamicLoadingKit.World" href="World.html">World</see>.
            </summary>
            <title>WorldCell Class</title>
            <category>Other Classes</category>
            <navigationName>WorldCell</navigationName>
            <fileName>WorldCell.html</fileName>
            <syntax>public class WorldCell : <see cref="T:DynamicLoadingKit.IAttachableWorldCell" href="IAttachableWorldCell.html">IAttachableWorldCell</see>, <see cref="T:DynamicLoadingKit.IDetachableWorldCell" href="IDetachableWorldCell.html">IDetachableWorldCell</see></syntax>
        </member>
        <member name="P:DynamicLoadingKit.WorldCell.CellObjectPosition">
            <summary>
            Gets the position that the cell object should be placed at. You can position the object manually, or 
            let it be automatically positioned via AttachCellObjectToCell (by passing in false for 
            objectPositionedCorrectlyAlready).
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DynamicLoadingKit.WorldCell.CellOnWorldGrid">
            <summary>
            Gets the cell's index on the World Grid associated with the World this cell belongs to.
            </summary>
            <type link="Cell.html">Cell</type>
        </member>
        <member name="P:DynamicLoadingKit.WorldCell.CellOnEndlessGrid">
            <summary>
            Gets the cells index on the Endless Grid associated with the World the cell belongs to.
            </summary>
            <type link = "Cell.html">Cell</type>
        </member>
        <member name="P:DynamicLoadingKit.WorldCell.CellPosition">
            <summary>
            Gets the position of the cell in world space (note, this may be different than the position of the 
            cell object, since the cell object can be offset from the cell).
            </summary>
            <type>Vector3</type>
        </member>
        <member name="P:DynamicLoadingKit.WorldCell.CellUsers">
            <summary>
            Gets the number of users of this World Cell.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DynamicLoadingKit.WorldCell.DoesCellHaveUsers">
            <summary>
            Gets a value indicating whether the World Cell currently has any users.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DynamicLoadingKit.WorldCell.Height">
            <summary>
            Gets the height of the cell.
            </summary>
            <type>float</type>
        </member>
        <member name="P:DynamicLoadingKit.WorldCell.CellObject">
            <summary>
            Gets the Cell Object associated with the World Cell.
            </summary>
            <type>GameObject</type>
            <displayName>CellObject</displayName>
        </member>
        <member name="P:DynamicLoadingKit.WorldCell.Length">
            <summary>
            Gets the length of the cell.
            </summary>
            <type>float</type>
        </member>
        <member name="P:DynamicLoadingKit.WorldCell.Width">
            <summary>
            Gets the width of the cell.
            </summary>
            <type>float</type>
        </member>
        <member name="M:DynamicLoadingKit.WorldCell.DynamicLoadingKit#IAttachableWorldCell#AttachCellObjectToCell(UnityEngine.GameObject,System.Boolean)">
            <summary>
            Attaches a GameObject to the cell. If creating a custom Cell Object Loader or Primary Cell Object 
            Sub Controller class, you should either let the WorldCell position the cell object correctly by 
            passing in false for objectPositionedCorrectlyAlready, or position the object manually (or instantiate it 
            at the correct position) and pass in true. The correct position to manually position the object can be retrieved via 
            the CellObjectPosition property.
            <para>Explicit Interface Implementation for 
            <see cref="T:DynamicLoadingKit.IAttachableWorldCell" href="IAttachableWorldCell.html">IAttachableWorldCell</see>
            </para>
            </summary>
            <param name="obj" type = "GameObject" link = "http://docs.unity3d.com/ScriptReference/GameObject.html">
            The object to attach to the cell.
            </param>
            <param name="objectPositionedCorrectlyAlready" type="bool">
            If false, the object will be moved to its correct position. If you've already positioned the object at the correct 
            location (CellObjectPosition), you must pass in true.
            </param>
            <displayName id = "AttachCellObjectToCell">IAttachableWorldCell.AttachCellObjectToCell(GameObject, bool)</displayName>
            <syntax>void IAttachableWorldCell.AttachCellObjectToCell(GameObject obj)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.WorldCell.DynamicLoadingKit#IDetachableWorldCell#DetachCellObjectFromCell">
            <summary>
            Detaches a cell object from the World Cell. The object is returned and no longer associated with the World Cell.
            <para>Explicit Interface Implementation for <see cref="T:DynamicLoadingKit.IDetachableWorldCell" href="IDetachableWorldCell.html">IDetachableWorldCell</see></para>
            </summary>
            <displayName id="DetachCellObjectFromCell">IDetachableWorldCell.DetachCellObjectFromCell()</displayName>
            <syntax>GameObject IDetachableWorldCell.DetachCellObjectFromCell()</syntax>
            <returns type="GameObject">The cell object that was detached from the World Cell.</returns>
        </member>
        <member name="T:DynamicLoadingKit.WorldCellWithTerrain">
            <summary>
            Represents a WorldCell whose Cell Object is a Unity Terrain.
            </summary>
            <title>WorldCellWithTerrain Class</title>
            <category>Other Classes</category>
            <navigationName>WorldCellWithTerrain</navigationName>
            <fileName>WorldCellWithTerrain.html</fileName>
            <syntax>public class WorldCellWithTerrain : <see cref="T:DynamicLoadingKit.WorldCell" href="WorldCell.html">WorldCell</see></syntax>
        </member>
        <member name="P:DynamicLoadingKit.WorldCellWithTerrain.LeftNeighbor">
            <summary>
            Gets the WorldCellWithTerrain that neighbors this WorldCellWithTerrain on the left.
            </summary>
            <type link ="WorldCellWithTerrain.html">WorldCellWithTerrain</type>
        </member>
        <member name="P:DynamicLoadingKit.WorldCellWithTerrain.TopNeighbor">
            <summary>
            Gets the WorldCellWithTerrain that neighbors this WorldCellWithTerrain on the top.
            </summary>
            <type link ="WorldCellWithTerrain.html">WorldCellWithTerrain</type>
        </member>
        <member name="P:DynamicLoadingKit.WorldCellWithTerrain.RightNeighbor">
            <summary>
            Gets the WorldCellWithTerrain that neighbors this WorldCellWithTerrain on the right.
            </summary>
            <type link ="WorldCellWithTerrain.html">WorldCellWithTerrain</type>
        </member>
        <member name="P:DynamicLoadingKit.WorldCellWithTerrain.BottomNeighbor">
            <summary>
            Gets the WorldCellWithTerrain that neighbors this WorldCellWithTerrain on the bottom.
            </summary>
            <type link ="WorldCellWithTerrain.html">WorldCellWithTerrain</type>
        </member>
        <member name="P:DynamicLoadingKit.WorldCellWithTerrain.Terrain">
            <summary>
            Gets the Terrain associted with this WorldCellWithTerrain.
            </summary>
            <type>Terrain</type>
        </member>
        <member name="T:DynamicLoadingKit.NonPoolingPrimaryCellObjectSubController">
            <summary>
            Provides an implementation for a Primary Cell Object Sub Controller that destroys cell objects when they are not needed.
            </summary>
            <title>NonPoolingPrimaryCellObjectSubController Class</title>
            <category>Sub Controllers</category>
            <navigationName>NonPoolingPrimaryCellObjectSubController</navigationName>
            <fileName>NonPoolingPrimaryCellObjectSubController.html</fileName>
            <syntax>public sealed class NonPoolingPrimaryCellObjectSubController : <see cref="T:DynamicLoadingKit.PrimaryCellObjectSubController" href="PrimaryCellObjectSubController.html">PrimaryCellObjectSubController</see></syntax>
        </member>
        <member name="M:DynamicLoadingKit.NonPoolingPrimaryCellObjectSubController.AttachCellObjectsToCellsInSingleFrame``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Attaches the objects associated with the input cells to the cells in a single frame. The objects are first loaded by the 
            Cell Object Loader associated with the sub controller.
            <para>Note that T must implement the <see cref="T:DynamicLoadingKit.IAttachableWorldCell" href = "IAttachableWorldCell.html">IAttachableWorldCell</see> interface.</para>
            </summary>
            <typeparam name="T">The type of the cells.</typeparam>
            <param name="cells" type = "List&lt;T&gt;">The cells whose objects need to be attached.</param>
            <param name="primaryCellObjectSubControllerID" type="int">The ID of the user requesting the attachment.</param>
            <displayName id="AttachCellObjectsToCellsInSingleFrame">AttachCellObjectsToCellsInSingleFrame&lt;T&gt;(List&lt;T&gt;, int)</displayName>
            <syntax>public sealed override void AttachCellObjectsToCellsInSingleFrame&lt;T&gt;(List&lt;T&gt; cells, int primaryCellObjectSubControllerID)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.NonPoolingPrimaryCellObjectSubController.AttachCellObjectsToCells``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Attaches the objects associated with the input cells to the cells over a period of frames. Objects are first loaded by the 
            Cell Object Loader associated with the sub controller.
            </summary>
            <typeparam name="T">The type of the cells.</typeparam>
            <param name="cells" type = "List&lt;T&gt;">The cells whose objects need to be attached.</param>
            <param name="primaryCellObjectSubControllerID" type = "int">The ID of the user requesting the attachment.</param>
            <displayName id = "AttachCellObjectsToCells">AttachCellObjectsToCells&lt;T&gt;(List&lt;T&gt;, int)</displayName>
            <syntax>public sealed override IEnumerator&lt;YieldInstruction&gt; AttachCellObjectsToCells&lt;T&gt;(List&lt;T&gt; cells, int primaryCellObjectSubControllerID)</syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.</returns>
        </member>
        <member name="M:DynamicLoadingKit.NonPoolingPrimaryCellObjectSubController.DetachAndProcessCellObjectsFromDeactivatedCells``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Detaches and destroys the objects associated with the input cells over a period of frames.
            </summary>
            <typeparam name="T">The type of the cells.</typeparam>
            <param name="deactivatedCells" type = "List&lt;T&gt;">The cells whose objects need to be detached and processed.</param>
            <param name="primaryCellObjectSubControllerID" type = "int">The ID of the user requesting the detachment and processing.</param>
            <displayName id = "DetachAndProcessCellObjectsFromDeactivatedCells">DetachAndProcessCellObjectsFromDeactivatedCells&lt;T&gt;(List&lt;T&gt;, int)</displayName>
            <syntax>public sealed override IEnumerator&lt;YieldInstruction&gt; DetachAndProcessCellObjectsFromDeactivatedCells&lt;T&gt;(List&lt;T&gt; cells, int primaryCellObjectSubControllerID)</syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.</returns>
        </member>
        <member name="T:DynamicLoadingKit.PoolingPrimaryCellObjectSubController">
            <summary>
            Provides an implementation for a Primary Cell Object Sub Controller that pools cell objects when they are not in use.
            <para>The pooling system is very simple, so you may wish to create your own sub controller class that implements a more 
            advanced system.</para>
            </summary>
            <title>PoolingPrimaryCellObjectSubController Class</title>
            <category>Sub Controllers</category>
            <navigationName>PoolingPrimaryCellObjectSubController</navigationName>
            <fileName>PoolingPrimaryCellObjectSubController.html</fileName>
            <syntax>public sealed class PoolingPrimaryCellObjectSubController : <see cref="T:DynamicLoadingKit.PrimaryCellObjectSubController" href="PrimaryCellObjectSubController.html">PrimaryCellObjectSubController</see></syntax>
            
            <inspector name="Max Objects to Pool Per Cell" type="int">The maximum number of objects that will be stored in the pool for each cell. If adding a cell object 
            to the pool would cause the number of objects for that cell to exceed this max, that object is destroyed instead.
            <para>Set this to the lowest possible value you can, as the larger the number, the more memory is allocated up front to store the object references.</para></inspector>
        </member>
        <member name="M:DynamicLoadingKit.PoolingPrimaryCellObjectSubController.CreateNewUser(DynamicLoadingKit.ICellObjectGroup,System.Int32)">
            <summary>
            Creates a new PoolingPrimaryCellObjectSubControllerUser, which is a custom type which derives 
            from PrimaryCellObjectSubControllerUser. This user object contains an object pool used specifically by this class.
            </summary>
            <param name="cellObjectGroup" type="ICellObjectGroup" link="ICellObjectGroup.html">
            The cell object group being registered.
            </param>
            <param name="loaderID" type="int">
            The loaderID assigned to the sub controller when it registered with the Cell Object Loader it is using.
            </param>
            <displayName id = "CreateNewUser">CreateNewUser(ICellObjectGroup, int)</displayName>
            <syntax>protected sealed override PrimaryCellObjectSubControllerUser CreateNewUser(ICellObjectGroup cellObjectGroup, int loaderID)</syntax>
            <returns type = "PrimaryCellObjectSubControllerUser">A new user object created using the worldAssociatedWithUser as input.</returns>
        </member>
        <member name="M:DynamicLoadingKit.PoolingPrimaryCellObjectSubController.AttachCellObjectsToCellsInSingleFrame``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Attaches the objects associated with the input cells to the cells in a single frame. Looks for the objects in the pool first, and if not found, loads the 
            objects into the scene via the Cell Object Loader.
            <para>Note that T must implement the <see cref="T:DynamicLoadingKit.IAttachableWorldCell" href = "IAttachableWorldCell.html">IAttachableWorldCell</see> interface.</para>
            </summary>
            <typeparam name="T">The type of the cells.</typeparam>
            <param name="cells" type = "List&lt;T&gt;">The cells whose objects need to be attached.</param>
            <param name="primaryCellObjectSubControllerID" type="int">The ID of the user requesting the attachment.</param>
            <displayName id="AttachCellObjectsToCellsInSingleFrame">AttachCellObjectsToCellsInSingleFrame&lt;T&gt;(List&lt;T&gt;, int)</displayName>
            <syntax>public sealed override void AttachCellObjectsToCellsInSingleFrame&lt;T&gt;(List&lt;T&gt; cells, int primaryCellObjectSubControllerID)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.PoolingPrimaryCellObjectSubController.AttachCellObjectsToCells``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Attaches the objects associated with the input cells to the cells over a period of frames. Looks for the objects 
            in the pool first, and if not found, has the Cell Object Loader load them into the scene.
            </summary>
            <typeparam name="T">The type of the cells.</typeparam>
            <param name="cells" type = "List&lt;T&gt;">The cells whose objects need to be attached.</param>
            <param name="primaryCellObjectSubControllerID" type = "int">The ID of the user requesting the attachment.</param>
            <displayName id = "AttachCellObjectsToCells">AttachCellObjectsToCells&lt;T&gt;(List&lt;T&gt;, int)</displayName>
            <syntax>public sealed override IEnumerator&lt;YieldInstruction&gt; AttachCellObjectsToCells&lt;T&gt;(List&lt;T&gt; cells, int primaryCellObjectSubControllerID)</syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.</returns>
        </member>
        <member name="M:DynamicLoadingKit.PoolingPrimaryCellObjectSubController.DetachAndProcessCellObjectsFromDeactivatedCells``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Detaches and pools the objects associated with the input cells over a period of frames. If there is not enough room 
            in the pool for an object, it is destroyed instead.
            </summary>
            <typeparam name="T">The type of the cells.</typeparam>
            <param name="deactivatedCells" type = "List&lt;T&gt;">The cells whose objects need to be detached and processed.</param>
            <param name="primaryCellObjectSubControllerID" type = "int">The ID of the user requesting the detachment and processing.</param>
            <displayName id = "DetachAndProcessCellObjectsFromDeactivatedCells">DetachAndProcessCellObjectsFromDeactivatedCells&lt;T&gt;(List&lt;T&gt;, int)</displayName>
            <syntax>public sealed override IEnumerator&lt;YieldInstruction&gt; DetachAndProcessCellObjectsFromDeactivatedCells&lt;T&gt;(List&lt;T&gt; cells, int primaryCellObjectSubControllerID)</syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.</returns>
        </member>
        <member name="T:DynamicLoadingKit.World">
            <summary>
            Represents a World that can either be endless or non endless. When endless, the world repeats itself over and over again
            endlessly. The World can also be set to stay centered around its origin, which is useful when dealing with large worlds 
            where floating point imprecision can be an issue.
            <para>
            Worlds represent the cells of your World Grid in game. Unlike the World Grid, which is just a collection 
            of data, the World has an origin in scene space and you can manipulate the make-up of the world at any time.
            </para>
            <para>
            This is done by adding and removing cell users from the cells of the BaseWorld. When a cell on the world has no users, it remains in or transitions to 
            an inactivate state, where its objects are not loaded into the scene. Once a cell has users, it becomes active and the objects associated 
            with that cell are loaded into the scene.
            </para>
            <para>
            By design, the Active Grid is the only component which adds and removes cell users to and from the world, though you are free to design your own systems that also do so.
            </para>
            <para>
            Add and remove request are processed over several frames, and it's possible for these requests to cancel each other out. Once processed, 
            the world is updated (objects are added and/or removed from the scene) and then the World waits for additional requests, or processes requests 
            received while the world was updating. This cycle repeats for the life of the World.
            </para>
            <para>
            Also note that once a World Grid is added to the World in the inspector, some new options become visible. These options allow you 
            to load the objects that make up your world into the scene view for use in the editor. For more information, please take a look at the 
            <see href="http://deepspacelabs.net/files/Dynamic%20Loading%20Kit_Full_Guide.pdf">Dynamic Loading Kit Full Guide</see>.
            </para>
            <para>
            A World should only be disabled (or its game object disabled) if it is being used as a prototype to create worlds 
            at runtime. Do not disable a World with the intention of enabling/using it at a later time, as this will not work properly. Instead, 
            you should create the World via the Component Manager, and destroy it when it is no longer needed.
            </para>
            </summary>
            <title>World Class</title>
            <category>Primary Components</category>
            <navigationName>World</navigationName>
            <fileName>World.html</fileName>
            <syntax>public sealed class World : MonoBehaviour, <see cref="T:DynamicLoadingKit.IIdentifiable" href="IIdentifiable.html">IIdentifiable</see>, <see cref="T:DynamicLoadingKit.ICellObjectGroup" href="ICellObjectGroup.html">ICellObjectGroup</see></syntax>
            
            <inspector name ="Are Columns Endless" type="bool">
            If checked, the columns of this world will be endless, i.e., when the player reaches
            the edge of the world on whatever axis the columns are on, the world will repeat.
            </inspector>
            
            <inspector name ="Are Layers Endless" type="bool">
            If checked, the layers of this world will be endless, i.e., when the player reaches
            the edge of the world on whatever axis the layers are on, the world will repeat.
            <para>
            This option is only used when the World Grid associated with the World has a "World Type" of "Three Dimensional".
            </para>
            </inspector>
            
            <inspector name ="Are Rows Endless" type="bool">
            If checked, the rows of this world will be endless, i.e., when the player reaches
            the edge of the world on whatever axis the rows are on, the world will repeat.
            </inspector>
            
            <inspector name ="Load Cushion" type="float">
            Hover over this option in the inspector for a detailed explanation, or view
            the <see href="http://deepspacelabs.net/files/Dynamic%20Loading%20Kit_Full_Guide.pdf">Dynamic Loading Kit Full Guide</see>. Basically, smaller values will result in faster dynamic loading, but will increase
            the frequency of redundant operations (a cell being loaded and then unloaded soon after), which may hinder performance.</inspector>
            
            <inspector name="Primary Cell Object Sub Controller" type="PrimaryCellObjectSubController" link="PrimaryCellObjectSubController.html">
            The Primary Cell Object Sub Controller that will be used by the World. The sub controller is responsible for retrieving objects
            when needed and disposing of objects when not needed. This component must be provided!</inspector>
            
            <inspector name="Use this Game Object's Position as World Origin" type="bool">
            If checked, the world position of whatever game object this World component is attached to will be used for the World's origin.
            <para>Note that changing the game objects position during the game will have no effect on the world's position.</para></inspector>
            
            <inspector name="World Grid" type="WorldGridBase" link="WorldGridBase.html">
            The World Grid that should be used as a blue print to build the world. This determines the size of the World's cells and what objects
            are loaded.</inspector>
            
            <inspector name="World ID" type="int">The ID that uniquely identifies this World. If multiple Worlds/ShiftableWorlds exist in the same scene,
            it is imperative that their ID's be unique. When creating World's at runtime via the 
            <see cref="T:DynamicLoadingKit.ComponentManager" href="ComponentManager.html">Component Manager</see>, a unique ID is automatically
            assigned to the created World.</inspector>
            
            <inspector name="World Origin" type="Vector3">The origin of this World. This option is hidden if 
            "Use this Game Object's Position as World Origin" is checked.</inspector>
        </member>
        <member name="P:DynamicLoadingKit.World.HaveWorldCellsBeenFullyLoaded">
            <summary>
            Gets a value indicating whether at least one world cell has been fully loaded for this world. Methods that try and retrieve world cells should not be used until this property returns true.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DynamicLoadingKit.World.AreColumnsEndless">
            <summary>
            Gets a value indicating whether the World's columns are endless.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DynamicLoadingKit.World.AreLayersEndless">
            <summary>
            Gets a value indicating whether the World's layers are endless.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DynamicLoadingKit.World.AreRowsEndless">
            <summary>
            Gets a value indicating whether the World's rows are endless.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DynamicLoadingKit.World.GroupName">
            <summary>
            Gets the group name of the object group associated with the World. This will most likely be the same as 
            the Group Name of the World Grid linked to this World, unless you have changed the group name via the 
            <see cref="M:DynamicLoadingKit.World.ChangeGroupName(System.String,System.Boolean)" href="#ChangeGroupName">ChangeGroupName</see> method.
            </summary>
            <type>string</type>
        </member>
        <member name="P:DynamicLoadingKit.World.IsIdle">
            <summary>
            Gets a value indicating whether the world is idle (Update cycle not running).
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DynamicLoadingKit.World.IsInitialized">
            <summary>
            Gets a value indicating whether the World has been initialized yet.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DynamicLoadingKit.World.IsWorldPersistent">
            <summary>
            Gets a value indicating whether the World is persistent between game sessions.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DynamicLoadingKit.World.IsOriginCellUpdateInProgress">
            <summary>
            Gets a value indicated whether a World Shift is currently in progress.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DynamicLoadingKit.World.ID">
            <summary>
            Gets the unique ID of the World.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DynamicLoadingKit.World.IsWorld3D">
            <summary>
            Gets a value indicating whether the World is three dimensional.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DynamicLoadingKit.World.IsWorldOriginCentered">
            <summary>
            Gets a value indicating whether the World is set to stay centered about the origin.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DynamicLoadingKit.World.NamingConvention">
            <summary>
            Gets the Naming Convention used by this World.
            </summary>
            <type link = "INamingConvention.html">INamingConvention</type>
        </member>
        <member name="P:DynamicLoadingKit.World.OriginCell">
            <summary>
            The current origin cell of the world. If using a world that doesn't stay centered around the origin,
            this should always be row = 1, column = 1, and layer = 1. The layer will also always be 1 if using a 2D world.
            </summary>
            <type link="Cell.html">Cell</type>
        </member>
        <member name="P:DynamicLoadingKit.World.OriginCellPosition">
            <summary>
            Gets the position of the origin cell, which is always equal to the world origin.
            </summary>
            <type>Vector3</type>
        </member>
        <member name="P:DynamicLoadingKit.World.OriginColumnPosition">
            <summary>
            The position of the origin cell column. Will always be the x value of the world origin.
            </summary>
            <type>float</type>
        </member>
        <member name="P:DynamicLoadingKit.World.OriginLayerPosition">
            <summary>
            The position of the origin cell layer. For 3D worlds, will be the y value of the world origin. For 2D worlds, will be 0.
            <para>Not valid until after ManagedAwake has been called.</para>
            </summary>
            <type>float</type>
        </member>
        <member name="P:DynamicLoadingKit.World.OriginRowPosition">
            <summary>
            The position of the origin cell row.
            <para>Not valid until after ManagedAwake has been called.</para>
            </summary>
            <type>float</type>
        </member>
        <member name="P:DynamicLoadingKit.World.PersistentDataSaveKey">
            <summary>
            Gets the Persistent Data Save Key for this World. This is only valid if 
            "Use Custom Save/Load Solution" is not checked on your Component Manager.
            </summary>
            <type>string</type>
        </member>
        <member name="P:DynamicLoadingKit.World.PrototypeConstructedFrom">
            <summary>
            Returns the Prototype this runtime created World was constructed from. If the world is an inspector 
            created World rather than a Runtime created one, this will return 0.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DynamicLoadingKit.World.PrimaryCellObjectSubControllerID">
            <summary>
            Gets the primaryCellObjectSubControllerID of this world.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DynamicLoadingKit.World.WorldGrid">
            <summary>
            Gets the World Grid associated with the World.
            </summary>
            <type link = "WorldGridBase.html">WorldGridBase</type>
        </member>
        <member name="P:DynamicLoadingKit.World.WorldOrigin">
            <summary>
            Gets the origin of the World. Will not be valid until after 
            the world has been initialized.
            <para>If you are trying to access the position of the origin layer, origin row, or origin column, 
            use the corresponding properties, as they will automatically take into account the World Type.</para>
            </summary>
            <type>Vector3</type>
        </member>
        <member name="P:DynamicLoadingKit.World.WorldState">
            <summary>
            Gets the current WorldState of the World.
            </summary>
            <type link="WorldState.html">WorldState</type>
        </member>
        <member name="P:DynamicLoadingKit.World.DynamicLoadingKit#ICellObjectGroup#World">
            <summary>
            Gets the World associated with the Cell Object Group implementating object.
            <para>Explicit Interface Implementation for 
            <see cref="T:DynamicLoadingKit.ICellObjectGroup" href="ICellObjectGroup.html">ICellObjectGroup</see>
            </para>
            </summary>
            <type link="World.html">World</type>
            <displayName>ICellObjectGroup.World</displayName>
        </member>
        <member name="M:DynamicLoadingKit.World.GetPersistentStringSaveData(System.Text.StringBuilder)">
            <summary>
            Gets persistent save data for the World in the form of a string. This can be used when creating a new 
            World via the Component Manager's CreatePersistentWorld or CreateNonPersistentWorld methods.
            </summary>
            <param name="stringBuilder" type="StringBuilder">A string builder object that will be used to create the string save data.</param>
            <returns type="string">The string save data.</returns>
            <displayName id="GetPersistentStringSaveData1">GetPersistentStringSaveData(StringBuilder)</displayName>
            <syntax>public string GetPersistentStringSaveData(StringBuilder stringBuilder)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.World.GetPersistentStringSaveData">
            <summary>
            Gets persistent save data for the World in the form of a string. This can be used when creating a new 
            World via the Component Manager's CreatePersistentWorld or CreateNonPersistentWorld methods.
            </summary>
            <returns type="string">The string save data.</returns>
            <displayName id="GetPersistentStringSaveData2">GetPersistentStringSaveData()</displayName>
            <syntax>public string GetPersistentStringSaveData()</syntax>
        </member>
        <member name="M:DynamicLoadingKit.World.UpdateLoadCushion(System.Single)">
            <summary>
            Updates the Load Cushion used by the World.
            <para>
            The load cushion is the amount of time the World will wait after it receives cell add/remove request or a 
            world shift order before proceeding with a World Update or Shift. Increasing 
            the load cushion time gives your player time cross additional boundaries before the world is updated.
            This can reduce some loading/unloading that occurs as the result of a very fast moving player 
            or small terrain/object sizes.
            </para>
            </summary>
            <param name="newLoadCushion" type="float">The new load cushion, in seconds.</param>
            <displayName id="UpdateLoadCushion">UpdateLoadCushion(float)</displayName>
            <syntax>public void UpdateLoadCushion(float newLoadCushion)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.World.Register(DynamicLoadingKit.IWorldUser,System.Int32@)">
            <summary>
            Register an IOriginCenteredWorldUser user with the World. This is only necessary when the world is set to stay 
            centered around the origin, so that as the world shifts (to stay centered), users can be prepared pre-shift and notified 
            post shift (in order to adjust player/boundaries/etc.). Custom users can be setup, though some guidelines must be followed. 
            See the <see cref="T:DynamicLoadingKit.IWorldUser" href="IWorldUser.html">IWorldUser</see> page for more information.
            </summary>
            <param name="user" type="IWorldUser" link="IWorldUser.html">The user to register.</param>
            <param name="registrationID" type="out int">The ID assigned to the user upon registration. You must pass in this ID when de-registering.</param>
            <displayName id="Register">Register(IOriginCenteredWorldUser, out int)</displayName>
            <syntax>public void Register(IOriginCenteredWorldUser user, out int registrationID)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.World.DeRegister(System.Int32)">
            <summary>
            Deregister a user from the World. Note that if the user is currently "prepared" for a world shift, they will NOT receive 
            notification from the World once the shift is completed.
            </summary>
            <param name="registrationID">The ID of the user that should be de registered.</param>
            <displayName id="DeRegister">DeRegister(int)</displayName>
            <syntax>public void DeRegister(int registrationID)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.World.AddCellUsersAndWaitForCellObjectsToBeLoaded(System.Collections.Generic.IList{DynamicLoadingKit.Cell})">
            <summary>
            Adds cell users to the specified list of cells and then waits for the cell objects associated with those cells to be loaded into the scene.
            <para>Note that objects are not guaranteed to be loaded for a given cell. For instance, if another soruce sends in a remove cell user request for a cell 
            you've sent an add user request in for, the two requests will cancel out and the cell will not be activated (and thus the object will not be loaded).</para>
            </summary>
            <param name="cellsToAddUsersTo" type="IList&lt;Cell&gt;" link="Cell.html">The list of cells to add users to.</param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.</returns>
            <exception name="InvalidOperationException">
            Thrown when this method is called before the World has been initialized.
            </exception>
            <displayName id="AddCellUsersAndWaitForCellObjectsToBeLoaded">AddCellUsersAndWaitForCellObjectsToBeLoaded(IList&lt;Cell&gt;)</displayName>
            <syntax>public IEnumerator&lt;YieldInstruction&gt; AddCellUsersAndWaitForCellObjectsToBeLoaded(IList&lt;Cell&gt; cellsToAddUsersTo)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.World.RemoveCellUsersAndWaitForCellObjectsToBeUnloaded(System.Collections.Generic.IList{DynamicLoadingKit.Cell})">
            <summary>
            Remove cell users from the specified list of cells and then waits for the cell objects associated with those cells to be unloaded from the scene.
            <para>Note that objects are not guaranteed to be unloaded for a given cell. For instance, if another soruce sends in a add cell user request for a cell 
            you've sent a remove user request in for, the two requests will cancel out and the cell will remain active (and thus the objects will not be unloaded).</para>
            </summary>
            <param name="cellsToRemoveUsersFrom" type="IList&lt;Cell&gt;" link="Cell.html">The list of cells to remove users from.</param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.</returns>
            <exception name="InvalidOperationException">
            Thrown when this method is called before the World has been initialized.
            </exception>
            <displayName id="RemoveCellUsersAndWaitForCellObjectsToBeUnloaded">RemoveCellUsersAndWaitForCellObjectsToBeUnloaded(IList&lt;Cell&gt;)</displayName>
            <syntax>public IEnumerator&lt;YieldInstruction&gt; RemoveCellUsersAndWaitForCellObjectsToBeUnloaded(IList&lt;Cell&gt; cellsToRemoveUsersFrom)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.World.RemoveAllCellUsersAndCellObjects">
            <summary>
            Removes all cell users from every cell on the world. This will effectively unload all the objects that make up your world.
            <para>Using the method manually is not recommended, as any Active Grids synced to this world that have objects loaded will not be notified that 
            the objects have been removed. This will result in those grids thinking the objects are loaded when they are in fact not. It is better to remove the objects via each 
            individual Active Grid.</para>
            </summary>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.</returns>
            <exception name="InvalidOperationException">
            Thrown when this method is called before the World has been initialized.
            </exception>
            <displayName id="RemoveAllCellUsersAndCellObjects">RemoveAllCellUsersAndCellObjects()</displayName>
            <syntax>public IEnumerator&lt;YieldInstruction&gt; RemoveAllCellUsersAndCellObjects()</syntax>
        </member>
        <member name="M:DynamicLoadingKit.World.AddCellUsers(System.Collections.Generic.IList{DynamicLoadingKit.Cell})">
            <summary>
            Sends in a request to add users to the list of specified cells.
            </summary>
            <param name="cellsToAddUsersTo" type="IList&lt;Cell&gt;" link="Cell.html">The list of cells to add users to.</param>
            <exception name="InvalidOperationException">
            Thrown when this method is called before the World has been initialized.
            </exception>
            <displayName id="AddCellUsers">AddCellUsers(IList&lt;Cell&gt;)</displayName>
            <syntax>public IEnumerator&lt;YieldInstruction&gt; AddCellUsers(IList&lt;Cell&gt; cellsToAddUsersTo)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.World.RemoveCellUsers(System.Collections.Generic.IList{DynamicLoadingKit.Cell})">
            <summary>
            Sends in a request to remove users from the list of specified cells.
            </summary>
            <param name="cellsToRemoveUsersFrom" type="IList&lt;Cell&gt;" link="Cell.html">The list of cells to remove users from.</param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.</returns>
            <exception name="InvalidOperationException">
            Thrown when this method is called before the World has been initialized.
            </exception>
            <displayName id="RemoveCellUsers">RemoveCellUsers(IList&lt;Cell&gt;)</displayName>
            <syntax>public IEnumerator&lt;YieldInstruction&gt; RemoveCellUsers(IList&lt;Cell&gt; cellsToRemoveUsersFrom)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.World.AddCellUsersImmediately(System.Collections.Generic.IList{DynamicLoadingKit.Cell})">
            <summary>
            Adds users to the list of specified cells so the cells are activated and the objects associated with those 
            cells are loaded into the scene.
            <para>This is meant to be used to ensure objects are loaded before the first Update at the beginning of a scene, and 
            should only be called from the initial Awake phase at the start of a scene.</para>
            </summary>
            <param name="cellsToAddUsersTo" type="IList&lt;Cell&gt;" link="Cell.html">The list of cells to add users to.</param>
            <exception name="InvalidOperationException">
            Thrown when this method is called before the World has been initialized.
            </exception>
            <displayName id="AddCellUsersImmediately">AddCellUsersImmediately(IList&lt;Cell&gt;)</displayName>
            <syntax>public IEnumerator&lt;YieldInstruction&gt; AddCellUsersImmediately(IList&lt;Cell&gt; cellsToAddUsersTo)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.World.GetDimensionsOfWorldGridCell(DynamicLoadingKit.Cell)">
            <summary>
            Get the cell dimensions of cell on the World Grid. The indexes of this cell must fall within the range 
            of rows, columns, and/or layers of your World Grid.
            <para> For instance, in a 4 rows x 4 columns World Grid, a row or column index of
            0 or 5 would not be valid (but 1, 2, 3, or 4 would be).
            </para>
            </summary>
            <param name="worldGridCell" type="Cell" link="Cell.html">The cell on the World Grid whose dimensions should be retrieved.</param>
            <returns type="CellDimensions" link="CellDimensions.html">The cell dimensions of the cell.</returns>
            <displayName id="GetDimensionsOfWorldGridCell">GetDimensionsOfWorldGridCell(Cell)</displayName>
            <syntax>public CellDimensions GetDimensionsOfWorldGridCell(Cell worldGridCell)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.World.GetDimensionsOfEndlessGridCell(DynamicLoadingKit.Cell)">
            <summary>
            Get the cell dimensions of an endless grid cell (can be any value)
            </summary>
            <param name="endlessGridCell" type="Cell" link="Cell.html">The endless grid cell whose dimensions should be retrieved.</param>
            <returns type="CellDimensions" link="CellDimensions.html">The cell dimensions of the cell.</returns>
            <displayName id="GetDimensionsOfEndlessGridCell">GetDimensionsOfEndlessGridCell(Cell)</displayName>
            <syntax>public CellDimensions GetDimensionsOfEndlessGridCell(Cell endlessGridCell)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.World.GetPositionOfEndlessGridCell(DynamicLoadingKit.Cell)">
            <summary>
            Retrieves the position of an endless grid cell. Unlike world grid cells, the indexes of this cell can be any value.
            </summary>
            <param name="endlessGridCell" type="Cell" link="Cell.html">The cell whose position should be retrieved.</param>
            <returns>The position of the cell.</returns>
            <exception name="InvalidOperationException">
            Thrown when this method is called before the World has been initialized.
            </exception>
            <displayName id="GetPositionOfEndlessGridCell">GetPositionOfEndlessGridCell(Cell)</displayName>
            <syntax>public Vector3 GetPositionOfEndlessGridCell(Cell endlessGridCell)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.World.GetPositionOfEndlessGridCellUsingTheoreticalOriginCell(DynamicLoadingKit.Cell,DynamicLoadingKit.Cell)">
            <summary>
            Gets the position of an endless grid cell as if a specific origin cell is the origin cell of this world.
            </summary>
            <param name="endlessGridCell" type="Cell" link="Cell.html">
            The one based endless grid cell whose position will be returned.
            </param>
            <param name="theoreticalOriginCell" type="Cell" link="Cell.html">
            The theoretical origin cell to base the endless grid cells 
            position on.
            </param>
            <returns>The position of the endless grid cell.</returns>
            <displayName id="GetPositionOfEndlessGridCellUsingTheoreticalOriginCell">
            GetPositionOfEndlessGridCellUsingTheoreticalOriginCell(Cell, Cell)
            </displayName>
            <syntax>
            public Vector3 GetPositionOfEndlessGridCellUsingTheoreticalOriginCell(Cell endlessGridCell, Cell theoreticalOriginCell)
            </syntax>
            <exception name="InvalidOperationException">
            Thrown when this method is called before the World has been initialized.
            </exception>
        </member>
        <member name="M:DynamicLoadingKit.World.FindEndlessGridCellPositionIsInUsingTheoreticalOriginCell(UnityEngine.Vector3,DynamicLoadingKit.Cell)">
            <summary>
            Finds the endless grid cell that the input position would be in if the origin cell of this world 
            were equal to the theoretical origin cell provided.
            <para>
            This is useful if you're about to change the origin cell via the Active Grid's TryMakeCellOriginCell 
            method and need to calculate some data based on the new origin cell.
            </para>
            <para>
            Note that a shift of the world back to the origin will shift the 
            endless grid values of all active cells, so if you are depending on the endless grid cell value remaining constant 
            while using origin recentering, you will run into issues.
            </para>
            </summary>
            <param name="position">The position to use to find the endless grid cell.</param>
            <param name="theoreticalOriginCell">
            The theoretical origin cell to use to find the endlesss grid cell.</param>
            <returns type="Cell" link="Cell.html">
            The endless grid cell the position would be in if the theoretical origin cell was the 
            origin cell of this world.
            </returns>
            <exception name="InvalidOperationException">
            Thrown when this method is called before the World has been initialized.
            </exception>
            <displayName id="FindEndlessGridCellPositionIsInUsingTheoreticalOriginCell">
            FindEndlessGridCellPositionIsInUsingTheoreticalOriginCell(Vector3, Cell)
            </displayName>
            <syntax>
            public Cell FindEndlessGridCellPositionIsInUsingTheoreticalOriginCell(Vector3 position, Cell theoreticalOriginCell)
            </syntax>
        </member>
        <member name="M:DynamicLoadingKit.World.FindEndlessGridCellPositionIsIn(UnityEngine.Vector3)">
            <summary>
            Finds the endless grid cell that the specified position falls within.
            Note that a shift of the world back to the origin will shift the 
            endless grid values of all active cells, so if you are depending on the endless grid cell value remaining constant 
            while using origin recentering, you will run into issues.
            <para>
            Note that the returned cell is 1 based.
            </para>
            </summary>
            <param name="position" type="Vector3">The position in world space.</param>
            <returns type="Cell" link="Cell.html">The endless grid cell the position falls within.</returns>
            <exception name="InvalidOperationException">
            Thrown when this method is called before the World has been initialized.
            </exception>
            <displayName id="FindEndlessGridCellPositionIsIn1">FindEndlessGridCellPositionIsIn(Vector3)</displayName>
            <syntax>public Cell FindEndlessGridCellPositionIsIn(Vector3 position)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.World.FindEndlessGridCellPositionIsIn(UnityEngine.Vector3,UnityEngine.Vector3@)">
            <summary>
            Finds the endless grid cell that the specified position falls within. Also outputs how much the found endless grid 
            cell is displaced from the origin cell. Note that a shift of the world back to the origin will shift the 
            endless grid values of all active cells, so if you are depending on the endless grid cell value remaining constant 
            while using origin recentering, you will run into issues.
            </summary>
            <param name="position" type="Vector3">The position in world space.</param>
            <param name="endlessGridCellDisplacementFromOrigin" type="out Vector3">The displacement of the found endless 
            grid cell in relation to the origin cell's position.</param>
            <returns type="Cell" link="Cell.html">The endless grid cell the position falls within.</returns>
            <exception name="InvalidOperationException">
            Thrown when this method is called before the World has been initialized.
            </exception>
            <displayName id="FindEndlessGridCellPositionIsIn2">
            FindEndlessGridCellPositionIsIn(Vector3, out Vector3)
            </displayName>
            <syntax>
            public Cell FindEndlessGridCellPositionIsIn(Vector3 position, out Vector3 endlessGridCellDisplacementFromOrigin)
            </syntax>
        </member>
        <member name="M:DynamicLoadingKit.World.GetPositionAndDimensionsOfEndlessGridCell(DynamicLoadingKit.Cell,UnityEngine.Vector3@,DynamicLoadingKit.CellDimensions@)">
            <summary>
            Retrieves the position and dimensions of an endless grid cell.
            </summary>
            <param name="endlessGridCell" type="Cell" link="Cell.html">
            The endless grid cell whose position and dimensions should be retrieved.
            </param>
            <param name="positionOfCell" type="Vector3">
            The position of the cell (will be set when the method returns).
            </param>
            <param name="dimensionsOfCell" type="out CellDimensions" link="CellDimensions.html">
            The cell dimensions of the cell (will be set when the method returns).
            </param>
            <exception name="InvalidOperationException">
            Thrown when this method is called before the World has been initialized.
            </exception>
            <displayName id="GetPositionAndDimensionsOfEndlessGridCell">
            GetPositionAndDimensionsOfEndlessGridCell(Cell, out Vector3, out CellDimensions)
            </displayName>
            <syntax>
            public void GetPositionAndDimensionsOfEndlessGridCell(Cell endlessGridCell, out Vector3 positionOfCell, out CellDimensions dimensionsOfCell))
            </syntax>
        </member>
        <member name="M:DynamicLoadingKit.World.ConvertCellOnEndlessGridToCellOnWorldGrid(DynamicLoadingKit.Cell)">
            <summary>
            Converts an endless grid cell to its equivalent world grid cell. Each endless grid cell is just a projection 
            of a world grid cell, and thus has the same dimensions and object associations.
            <para>
            Note that the passed in cell should be 1 based. That is, the first cell in the grid has a row of 1, column of 1, 
            and layer of 1. The returned World Grid cell will also be 1 based.
            </para>
            </summary>
            <param name="cellOnEndlessGrid" type="Cell" link="Cell.html">The endless grid cell to be converted.</param>
            <returns type="Cell" link="Cell.html">The equivalent world grid cell for the endless grid cell specified.</returns>
            <displayName id="ConvertCellOnEndlessGridToCellOnWorldGrid">ConvertCellOnEndlessGridToCellOnWorldGrid(Cell)</displayName>
            <syntax>public Cell ConvertCellOnEndlessGridToCellOnWorldGrid(Cell cellOnEndlessGrid)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.World.TryGetWorldCellPositionIsIn(UnityEngine.Vector3,DynamicLoadingKit.WorldCell@,System.String@)">
            <summary>
            Tries to get the <see cref="T:DynamicLoadingKit.WorldCell" href="WorldCell.html">World Cell</see> that the 
            position is in. If no World Cell can be identified, false will be returned and worldCell will be null. 
            In this case, reasonForFailure can tell you important information on why the World Cell could not be 
            found, such as the position was outside the bounds of the World Grid or fell within the 
            bounds of an empty world grid cell.
            </summary>
            <param name="position" type="Vector3">
            The position to use to find the world cell.
            </param>
            <param name="worldCell" type="WorldCell" link="WorldCell.html">
            When this method returns, contains the world cell associated with the endless grid cell, or null 
            if a World Cell cannot be identified
            </param>
            <param name="reasonForFailure" type="WorldCell" link="WorldCell.html">
            If a World Cell was located, this will be null, otherwise it will contain a helpful message 
            you can use to debug the reason for the failure.
            </param>
            <syntax>
            public bool TryGetWorldCellPositionIsIn(Vector3 position, out WorldCell worldCell, out string reasonForFailure)
            </syntax>
            <displayName id="TryGetWorldCellPositionIsIn1">
            TryGetWorldCellPositionIsIn(Vector3, out WorldCell, out string)
            </displayName>
            <returns type="bool">A bool indicating whether the world cell was able to be retrieved.</returns>
            <exception name="InvalidOperationException">
            Thrown when this method is called before the World has been initialized.
            </exception>
        </member>
        <member name="M:DynamicLoadingKit.World.TryGetWorldCellPositionIsIn(UnityEngine.Vector3,DynamicLoadingKit.WorldCell@)">
            <summary>
            Tries to get the <see cref="T:DynamicLoadingKit.WorldCell" href="WorldCell.html">World Cell</see> that the 
            position is in. This method may fail to identify a World Cell for several reasons. If you are 
            having trouble identifing the reason, you can use the alternative method with the out 
            string parameter.
            </summary>
            <param name="position" type="Vector3">
            The position to use to find the world cell.
            </param>
            <param name="worldCell" type="WorldCell" link="WorldCell.html">
            When this method returns, contains the world cell associated with the endless grid cell, or null 
            if a World Cell cannot be identified
            </param>
            <syntax>
            public bool TryGetWorldCellPositionIsIn(Vector3 position, out WorldCell worldCell)
            </syntax>
            <displayName id="TryGetWorldCellPositionIsIn2">
            TryGetWorldCellPositionIsIn(Vector3, out WorldCell)
            </displayName>
            <returns type="bool">A bool indicating whether the world cell was able to be retrieved.</returns>
            <exception name="InvalidOperationException">
            Thrown when this method is called before the World has been initialized.
            </exception>
        </member>
        <member name="M:DynamicLoadingKit.World.TryGetWorldCellAssociatedWithEndlessGridCell(DynamicLoadingKit.Cell,DynamicLoadingKit.WorldCell@,System.String@)">
            <summary>
            Tries to get the <see cref="T:DynamicLoadingKit.WorldCell" href="WorldCell.html">World Cell</see> associated with 
            the endless grid cell. If no World Cell can be identified, false will be returned and 
            worldCell will be null. 
            In this case, reasonForFailure can tell you important information on why the World Cell could not be 
            found, such as the endless grid cell was outside the bounds of the World Grid 
            or was associated with an empty world grid cell.
            </summary>
            <param name="endlessGridCell" type="Cell" link="Cell.html">
            The endless grid cell to use to find the world cell.
            </param>
            <param name="worldCell" type="WorldCell" link="WorldCell.html">
            When this method returns, contains the world cell associated with the endless grid cell, or null 
            if a World Cell cannot be identified
            </param>
            <param name="reasonForFailure" type="WorldCell" link="WorldCell.html">
            If a World Cell was located, this will be null, otherwise it will contain a helpful message 
            you can use to debug the reason for the failure.
            </param>
            <syntax>
            public bool TryGetWorldCellAssociatedWithEndlessGridCell(Cell endlessGridCell, out WorldCell worldCell, out string reasonForFailure)
            </syntax>
            <displayName id="TryGetWorldCellAssociatedWithEndlessGridCell1">
            TryGetWorldCellAssociatedWithEndlessGridCell(Cell, out WorldCell, out string)
            </displayName>
            <returns type="bool">A bool indicating whether the world cell was able to be retrieved.</returns>
            <exception name="InvalidOperationException">
            Thrown when this method is called before the World has been initialized.
            </exception>
        </member>
        <member name="M:DynamicLoadingKit.World.TryGetWorldCellAssociatedWithEndlessGridCell(DynamicLoadingKit.Cell,DynamicLoadingKit.WorldCell@)">
            <summary>
            Tries to get the <see cref="T:DynamicLoadingKit.WorldCell" href="WorldCell.html">World Cell</see> that the 
            position is in. This method may fail to identify a World Cell for several reasons. If you are 
            having trouble identifing the reason, you can use the alternative method with the out 
            string parameter.
            </summary>
            <param name="endlessGridCell" type="Cell" link="Cell.html">
            The endless grid cell to use to find the world cell.
            </param>
            <param name="worldCell" type="WorldCell" link="WorldCell.html">
            When this method returns, contains the world cell associated with the endless grid cell, or null 
            if a World Cell cannot be identified.
            </param>
            <syntax>
            public bool TryGetWorldCellAssociatedWithEndlessGridCell(Cell endlessGridCell, out WorldCell worldCell)
            </syntax>
            <displayName id="TryGetWorldCellAssociatedWithEndlessGridCell2">
            TryGetWorldCellAssociatedWithEndlessGridCell(Cell, out WorldCell)
            </displayName>
            <returns type="bool">A bool indicating whether the world cell was able to be retrieved.</returns>
            <exception name="InvalidOperationException">
            Thrown when this method is called before the World has been initialized.
            </exception>
        </member>
        <member name="M:DynamicLoadingKit.World.GetRowAndLayerPositionOfCell(UnityEngine.Vector3,System.Single@,System.Single@)">
            <summary>
            Get the row and layer position of a cell given it's absolute world space position. 
            This is useful because 
            the row and layer positions may be using the y or z components of the Vector3, 
            depending on the World Type.
            <para>
            When WorldType is Two_Dimensional_On_XZ_Axes or Three_Dimensional Row Position uses z component and 
            Layer Position uses y component.
            </para>
            <para>
            When WorldType is Two_Dimensional_On_XY_Axes Row Position uses y component and Layer Position uses 
            z component.
            </para>
            </summary>
            <param name="cellPosition">The world space position of the cell.</param>
            <param name="rowPosition" type="float">
            The Row Position of the cell after this method returns.
            </param>
            <param name="layerPosition" type="float">
            The Layer Position of the cell after this method returns.
            </param>
            <exception name="InvalidOperationException">
            Thrown when this method is called before the World has been initialized.
            </exception>
            <syntax>
            public void GetRowPositionOfCell(Vector3 cellPosition, out float rowPosition, out float layerPosition)
            </syntax>
            <displayName id="GetRowPositionOfCell">
            GetRowPositionOfCell(Vector3, out float, out float)
            </displayName>
        </member>
        <member name="M:DynamicLoadingKit.World.PreInitialize_SetWorldOrigin(UnityEngine.Vector3,System.Boolean)">
            <summary>
            Changes the World Origin that this World will initially use. This must be called before the World has been initialized.
            </summary>
            <param name="newWorldOrigin" type="Vector3">
            The new world origin.
            </param>
            <param name="overwriteWorldOriginFromPersistentData" type="bool">
            Should the new world origin overwrite the world origin found in persistent data for this World (if any exist)?
            </param>
            <displayName id="PreInitialize_SetWorldOrigin">
            PreInitialize_SetWorldOrigin(Vector3, bool)
            </displayName>
            <syntax>
            public void PreInitialize_SetWorldOrigin(Vector3 newWorldOrigin, bool overwriteWorldOriginFromPersistentData)
            </syntax>
        </member>
        <member name="M:DynamicLoadingKit.World.PreInitialize_SetGroupName(System.String,System.Boolean)">
            <summary>
            Changes the Group Name that this World will initially use. This must be called before the World has been initialized.
            </summary>
            <param name="newGroupName" type="string">
            The new group name.
            </param>
            <param name="overwriteNameFromPersistentData" type="bool">
            Should the new group name overwrite the group name found in persistent data for this World (if any exist)?
            </param>
            <displayName id="PreInitialize_SetGroupName">
            PreInitialize_SetGroupName(string, bool)
            </displayName>
            <syntax>
            public void PreInitialize_SetGroupName(string newGroupName, bool overwriteNameFromPersistentData)
            </syntax>
        </member>
        <member name="M:DynamicLoadingKit.World.PreInitialize_SetOriginCell(DynamicLoadingKit.Cell,System.Boolean)">
            <summary>
            Changes the Origin Cell that this World will initially use. This must be called before the World has been initialized.
            </summary>
            <param name="newOriginCell" type="Cell" link="Cell.html">
            The new origin cell.
            <para>
            Note, this origin cell is 1 based, i.e., the bottom left most cell of the world has an index of row = 1, column = 1, and 
            layer = 1 (for 3D worlds). The origin cell in the save data, on the other hand, is 0 based.
            </para>
            <para>
            Also note the layer is only used if the World Grid is Three Dimensional.
            </para>
            </param>
            <param name="overwriteOriginCellFromPersistentData" type="bool">
            Should the new origin cell overwrite the origin cell found in persistent data for this World (if any exist)?
            </param>
            <displayName id="PreInitialize_SetOriginCell">
            PreInitialize_SetOriginCell(Cell, bool)
            </displayName>
            <syntax>
            public void PreInitialize_SetOriginCell(Cell newOriginCell, bool overwriteOriginCellFromPersistentData)
            </syntax>
        </member>
        <member name="M:DynamicLoadingKit.World.ChangeGroupName(System.String,System.Boolean)">
            <summary>
            Changes the Group Name of this World (change persist between sessions if the World is persistent) and 
            optionally refreshes the World so it will be made up entirely of the objects associated with the new group name. 
            </summary>
            <param name="newGroupName" type="string">
            The new group name.
            </param>
            <param name="refreshWorld" type="bool">
            If true, the objects related to the previous group name are completely unloaded, and the objects related to 
            the new group name are loaded.
            <para>
            This is useful for loading alternate versions of your terrain/objects (such as a lower resolution version) 
            mid-game. The alternate terrain/objects dimensions/type must match the normal versions dimensions/type. 
            For example, if the normal version of an object is a 500m x 500m terrain, the alternate version must also be a 500m x 500m terrain.
            </para>
            <para>
            This method will load the new objects first, then remove the old objects. This will not look good, so refreshWorld should 
            probably only be set to true if using a loading screen or some other method that hides the game view from the player.
            </para>
            </param>
            <exception name="InvalidOperationException">
            Thrown when the method is called before the World has been initialized.
            </exception>
            <displayName id="ChangeNameAndRefreshWorld">
            ChangeGroupName(string, bool)
            </displayName>
            <syntax>
            public IEnumerator&lt;YieldInstruction&gt; ChangeGroupName(string newGroupName, bool refreshWorld)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.
            </returns>
        </member>
        <member name="M:DynamicLoadingKit.World.Destroy">
            <summary>
            Deactivates all cells of the world and unloads the objects associated with those cells, then destroys the World component.
            <para>When destroyed, the World will de-register with the associated Primary Cell Object Sub Controller (so you don't need to worry about 
            doing this yourself).</para>
            </summary>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.</returns>
            <displayName id="Destroy">Destroy()</displayName>
            <syntax>public IEnumerator&lt;YieldInstruction&gt; Destroy()</syntax>
        </member>
        <member name="M:DynamicLoadingKit.World.InitIndependent_FindWorldGridCellPositionIsIn(UnityEngine.Vector3)">
            <summary>
            Finds the World Grid cell (One Based) that the specified position falls within. The current origin cell set in the 
            inspector will be used to calculate the world grid cell.
            <para>
            This method is safe to call at any time, even before the World has been initialized. This means it can even be called 
            on a World prototype.
            </para>
            </summary>
            <param name="position" type="Vector3">The position in scene space (aka world space within the Unity scene).</param>
            <returns type="Cell" link="Cell.html">The World Grid Cell the position falls within.</returns>
            <exception name="ArgumentOutOfRangeException">
            Thrown when the position argument is not within the bounds of the World.
            </exception>
            <displayName id="InitIndependent_FindWorldGridCellPositionIsIn">
            InitIndependent_FindWorldGridCellPositionIsIn(Vector3)
            </displayName>
            <syntax>
            public Cell InitIndependent_FindWorldGridCellPositionIsIn(Vector3 position)
            </syntax>
        </member>
        <member name="M:DynamicLoadingKit.World.InitIndependent_FindWorldGridCellPositionIsIn(UnityEngine.Vector3,DynamicLoadingKit.Cell)">
            <summary>
            Finds the World Grid cell (One Based) that the specified position falls within, based on the passed in 
            theoretical origin cell.
            <para>
            This method is safe to call at any time, even before the World has been initialized. This means it can even be called 
            on a World prototype.
            </para>
            </summary>
            <param name="position" type="Vector3">The position in scene space (aka world space within the Unity scene).</param>
            <param name="theoreticalOriginCell" type="Cell" link="Cell.html">
            The theoretical origin cell to base the calculation on.
            </param>
            <returns type="Cell" link="Cell.html">The World Grid Cell the position falls within.</returns>
            <exception name="ArgumentOutOfRangeException">
            Thrown when the position argument is not within the bounds of the World.
            </exception>
            <displayName id="InitIndependent_FindWorldGridCellPositionIsIn">
            InitIndependent_FindWorldGridCellPositionIsIn(Vector3)
            </displayName>
            <syntax>
            public Cell InitIndependent_FindWorldGridCellPositionIsIn(Vector3 position)
            </syntax>
        </member>
        <member name="T:DynamicLoadingKit.PrefabInstantiator">
            <summary>
            A Cell Object Loader which loads cell object prefabs into the scene via the 
            <see href="http://docs.unity3d.com/ScriptReference/Resources.Load.html">Resources.Load</see> and 
            <see href="http://docs.unity3d.com/ScriptReference/Object.Instantiate.html">Object.Instantiate</see>
            methods.
            <para>
            When using this component, it's imperative that your prefabs be located directly in a 
            folder named "Resources" (can't be in subfolders).
            </para>
            <para>
            You should never have to interact directly with this component, as the methods/properties are called/used
            as needed by the Dynamic Loading Kit.
            </para>
            </summary>
            <title>PrefabInstantiator Class</title>
            <category>Cell Object Loaders</category>
            <navigationName>PrefabInstantiator</navigationName>
            <fileName>PrefabInstantiator.html</fileName>
            <syntax>public class PrefabInstantiator : <see cref = "T:DynamicLoadingKit.CellObjectLoader" href = "CellObjectLoader.html">CellObjectLoader</see></syntax>
            <inspector name = "Time To Yield Between Instantiates" type = "float">Each method call will attempt to instantiate multiple objects. This instantiation process is carried out
            over a period of time for performance reasons. This value sets the amount of time to wait between calls of Instantiate.
            <para>A value of 0 will cause all objects to be Instantiated in a single frame and is not recommended.</para></inspector>
        </member>
        <member name="P:DynamicLoadingKit.PrefabInstantiator.IsSingleFrameAttachmentPreloadRequired">
            <summary>
            Because Instantiated prefabs do not need a frame to "process", pre-loading is not required, and so this
            property is overridden to return false.
            </summary>
            <type>bool</type>
        </member>
        <member name="M:DynamicLoadingKit.PrefabInstantiator.AttachCellObjectsToCellsInSingleFrame``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Instantiates and attaches all cell objects to the input cells in a single frame. This is not very performant and so should only
            be used in Awake or Start.
            </summary>
            <typeparam name="T">The type of the cells.</typeparam>
            <param name="cells" type = "List&lt;T&gt;">The cells whose objects need to be attached.</param>
            <param name="loaderID" type = "int">The ID of the user requesting the attached.</param>
            <displayName id = "AttachCellObjectsToCellsInSingleFrame">AttachCellObjectsToCellsInSingleFrame&lt;T&gt;(List&lt;T&gt;, int)</displayName>
            <syntax>public sealed override void AttachCellObjectsToCellsInSingleFrame&lt;T&gt;(List&lt;T&gt; cells, int loaderID)</syntax>
        </member>
        <member name="M:DynamicLoadingKit.PrefabInstantiator.LoadAndAttachCellObjectsToCells``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Loads and attaches the objects associated with the input cells to the cells over a period of frames.
            After each Instantiation, if "Time To Yield Between Instantiates" is greater than 0, that amount of time is yielded.
            </summary>
            <typeparam name="T">The type of the cells.</typeparam>
            <param name="cells" type = "List&lt;T&gt;">The cells whose objects need to be loaded and attached.</param>
            <param name="loaderID" type = "int">The ID of the user requesting the load and attachment.</param>
            <displayName id = "AttachCellObjectsToCellsInSingleFrame">LoadAndAttachCellObjectsToCells&lt;T&gt;(List&lt;T&gt;, int)</displayName>
            <syntax>public sealed override IEnumerator&lt;YieldInstruction&gt; AttachCellObjectsToCellsInSingleFrame&lt;T&gt;(List&lt;T&gt; cells, int loaderID)</syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine.</returns>
        </member>
        <member name="T:DynamicLoadingKit.SceneLoader">
            <summary>
            A Cell Object Loader component which loads objects via scenes. This is similar to the 
            <see cref = "T:DynamicLoadingKit.AsyncSceneLoader" href="AsyncSceneLoader.html">AsyncSceneLoader</see> component, except this version uses 
            <see href="http://docs.unity3d.com/ScriptReference/Application.LoadLevelAdditive.html">Application.LoadLevelAdditive</see> to load the scenes.
            <para>This means the main Unity thread will be blocked while the objects in the scene are loaded.</para>
            <para>You should never have to interact directly with this component, as the methods/properties are called/used
            as needed by the Dynamic Loading Kit.</para>
            </summary>
            <title>SceneLoader Class</title>
            <category>Cell Object Loaders</category>
            <navigationName>SceneLoader</navigationName>
            <fileName>SceneLoader.html</fileName>
            <syntax>public sealed class SceneLoader : <see cref = "T:DynamicLoadingKit.BaseSceneLoader" href = "BaseSceneLoader.html">BaseSceneLoader</see></syntax>
            <inspector name = "Time To Wait Between Loads" type = "float">The amount of time to yield (in seconds) between scene loads. For instance, a value of .3 will result in a scene being fully loaded, followed by
            the scene loader yielding for .3 seconds, followed by the second scene being fully loaded, and so on.
            <para>A value of 0 will result in no yielding between scene loads, but will most likely hinder performance.</para></inspector>
        </member>
        <member name="M:DynamicLoadingKit.SceneLoader.LoadCellObjectIntoLevel(System.String)">
            <summary>
            Loads the scene/objects with the name objectName into the current scene via <see href="http://docs.unity3d.com/ScriptReference/Application.LoadLevelAdditive.html">Application.LoadLevelAdditive</see>.
            </summary>
            <param name="objectName" type = "string">The name of the object/scene to load.</param>
            <displayName id = "LoadCellObjectIntoLevel">LoadCellObjectIntoLevel(string)</displayName>
            <syntax>protected sealed override YieldInstruction LoadCellObjectIntoLevel(string objectName)</syntax>
            <returns type = "YieldInstruction" link = "http://docs.unity3d.com/ScriptReference/YieldInstruction.html">If "Time To Wait Between Loads" is greater
            than 0, returns a WaitForSeconds object. Otherwise, null.</returns>
        </member>
    </members>
</doc>
